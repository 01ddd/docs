From 91c73577500a4c1a1703a439e74705f753b30c91 Mon Sep 17 00:00:00 2001
From: yuyz <yuyz@rock-chips.com>
Date: Wed, 3 May 2017 09:14:02 +0800
Subject: [PATCH] vehicle: add vehicle driver for px3se

Change-Id: I0d9f04729d9af462a3cabdb4cbc6a9425f3598ec
Signed-off-by: yuyz <yuyz@rock-chips.com>
---
 arch/arm/boot/dts/px3se-sdk.dts                    |   39 +
 arch/arm/boot/dts/px3se-sdk.dtsi                   |    5 +
 arch/arm/boot/dts/rk3128-cif-sensor.dtsi           |   93 +-
 arch/arm/configs/px3se_linux_defconfig             |    8 +-
 drivers/media/video/rk30_camera_oneframe.c         |    9 +-
 drivers/media/video/rk30_camera_pingpong.c         |    6 +
 drivers/misc/gpio-detection.c                      |    7 +-
 drivers/video/rockchip/Kconfig                     |    5 +
 drivers/video/rockchip/Makefile                    |    1 +
 drivers/video/rockchip/iep/iep.h                   |    2 +
 drivers/video/rockchip/iep/iep_drv.c               |   65 +
 drivers/video/rockchip/lcdc/rk312x_lcdc.c          |   53 +-
 drivers/video/rockchip/rga2/rga2_drv.c             |    6 +
 drivers/video/rockchip/rk_drm_fb.c                 |  300 +++-
 drivers/video/rockchip/rk_drm_fb.h                 |    2 +
 drivers/video/rockchip/rk_fb.c                     |  127 +-
 drivers/video/rockchip/vehicle/Makefile            |    8 +
 drivers/video/rockchip/vehicle/flinger.h           |   41 +
 drivers/video/rockchip/vehicle/vehicle_ad.h        |   65 +
 drivers/video/rockchip/vehicle/vehicle_ad_7181.c   |  421 +++++
 drivers/video/rockchip/vehicle/vehicle_ad_7181.h   |   13 +
 drivers/video/rockchip/vehicle/vehicle_ad_tp2825.c | 1054 +++++++++++++
 drivers/video/rockchip/vehicle/vehicle_ad_tp2825.h |   13 +
 drivers/video/rockchip/vehicle/vehicle_cfg.h       |   99 ++
 drivers/video/rockchip/vehicle/vehicle_cif.c       |  786 ++++++++++
 drivers/video/rockchip/vehicle/vehicle_cif.h       |  176 +++
 drivers/video/rockchip/vehicle/vehicle_dev.c       |  106 ++
 drivers/video/rockchip/vehicle/vehicle_flinger.c   | 1648 ++++++++++++++++++++
 drivers/video/rockchip/vehicle/vehicle_flinger.h   |   42 +
 .../rockchip/vehicle/vehicle_generic_sensor.c      |  263 ++++
 drivers/video/rockchip/vehicle/vehicle_gpio.c      |  159 ++
 drivers/video/rockchip/vehicle/vehicle_gpio.h      |   26 +
 drivers/video/rockchip/vehicle/vehicle_main.c      |  301 ++++
 drivers/video/rockchip/vehicle/vehicle_main.h      |   10 +
 include/linux/rk_fb.h                              |   25 +
 35 files changed, 5896 insertions(+), 88 deletions(-)
 mode change 100644 => 100755 drivers/video/rockchip/iep/iep_drv.c
 mode change 100644 => 100755 drivers/video/rockchip/rk_fb.c
 create mode 100644 drivers/video/rockchip/vehicle/Makefile
 create mode 100644 drivers/video/rockchip/vehicle/flinger.h
 create mode 100644 drivers/video/rockchip/vehicle/vehicle_ad.h
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_ad_7181.c
 create mode 100644 drivers/video/rockchip/vehicle/vehicle_ad_7181.h
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_ad_tp2825.c
 create mode 100644 drivers/video/rockchip/vehicle/vehicle_ad_tp2825.h
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_cfg.h
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_cif.c
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_cif.h
 create mode 100644 drivers/video/rockchip/vehicle/vehicle_dev.c
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_flinger.c
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_flinger.h
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_generic_sensor.c
 create mode 100644 drivers/video/rockchip/vehicle/vehicle_gpio.c
 create mode 100644 drivers/video/rockchip/vehicle/vehicle_gpio.h
 create mode 100755 drivers/video/rockchip/vehicle/vehicle_main.c
 create mode 100644 drivers/video/rockchip/vehicle/vehicle_main.h

diff --git a/arch/arm/boot/dts/px3se-sdk.dts b/arch/arm/boot/dts/px3se-sdk.dts
index 5dd2e7f..ea01afa 100644
--- a/arch/arm/boot/dts/px3se-sdk.dts
+++ b/arch/arm/boot/dts/px3se-sdk.dts
@@ -109,6 +109,45 @@
 		BT,wake_host_irq = <&gpio3 GPIO_C6 GPIO_ACTIVE_HIGH>;
 		status = "okay";
 	};
+	gpio_det:gpio-det {
+        compatible = "gpio-detection";
+        status = "okay";
+
+        car-reverse {
+            gpios = <&gpio2 GPIO_B1 GPIO_ACTIVE_LOW>;
+            linux,debounce-ms = <5>;
+            label = "car-reverse";
+            gpio,wakeup;
+        };
+
+        car-acc {
+            gpios = <&gpio2 GPIO_B0 GPIO_ACTIVE_LOW>;
+            linux,debounce-ms = <5>;
+            label = "car-acc";
+            gpio,wakeup;
+        };
+    };
+
+	vehicle {
+		compatible = "vehicle";
+
+		pinctrl-names = "vehicle";
+		pinctrl-0 = <&vehicle_irq_gpio>;
+
+		clocks = <&pd_vip>,<&clk_gates6 5>,<&clk_gates6 4>,<&clk_cif0_in>,<&clk_cif_out>;
+		clock-names = "pd_cif0", "aclk_cif0","hclk_cif0","cif0_in","cif0_out";
+
+		rockchip,cif = <&cif>;
+		rockchip,gpio-det = <&gpio_det>;
+		rockchip,cif-sensor = <&rk3128_cif_sensor>;
+
+		ad,fix-format = <0>;//0:auto detect,1:pal;2:ntsc;3:720p50;4:720p30;5:720p25
+		/*0:no, 1:90; 2:180; 4:270; 0x10:mirror-y; 0x20:mirror-x*/
+		vehicle,rotate-mirror = <0x00>;
+	};
+};
+&ion_cma {
+	reg = <0x00000000 0x2000000>; /* 16MB */
 };
 
 &fb {
diff --git a/arch/arm/boot/dts/px3se-sdk.dtsi b/arch/arm/boot/dts/px3se-sdk.dtsi
index c0d9a57..f755e95 100644
--- a/arch/arm/boot/dts/px3se-sdk.dtsi
+++ b/arch/arm/boot/dts/px3se-sdk.dtsi
@@ -1039,6 +1039,11 @@
 			rockchip,pins = <GPIO2_C6>;
 			rockchip,pull = <VALUE_PULL_UP>;
 		};
+
+		vehicle_irq_gpio: vehicle-irq-gpio {
+			rockchip,pins = <GPIO2_B1>;
+			rockchip,pull = <VALUE_PULL_UPDOWN_DISABLE>;
+		};
 	};
 };
 
diff --git a/arch/arm/boot/dts/rk3128-cif-sensor.dtsi b/arch/arm/boot/dts/rk3128-cif-sensor.dtsi
index 1b5816d..f0672a5 100755
--- a/arch/arm/boot/dts/rk3128-cif-sensor.dtsi
+++ b/arch/arm/boot/dts/rk3128-cif-sensor.dtsi
@@ -9,82 +9,37 @@
 			CONFIG_SENSOR_FLASH_IOCTL_USR	  	= <0>;
 			CONFIG_SENSOR_AF_IOCTL_USR	   		= <0>;
 
-		ov2659{
-			is_front = <1>;
-			rockchip,powerdown = <&gpio3 GPIO_D7 GPIO_ACTIVE_HIGH>;
-			pwdn_active = <ov2659_PWRDN_ACTIVE>;
-			#rockchip,power = <>;
+		adv7181 {
+			status = "okay";
+			is_front = <0>;
+			//rockchip,power = <&gpio0 GPIO_D0 GPIO_ACTIVE_HIGH>;
+			rockchip,powerdown = <&gpio3 GPIO_B3 GPIO_ACTIVE_HIGH>;
+			//irq_active = <&gpio1 GPIO_B5 IRQ_TYPE_EDGE_FALLING>;
+			//rockchip,reset = <&gpio3 GPIO_B3 GPIO_ACTIVE_HIGH>;
+			pwdn_active = <adv7181_PWRDN_ACTIVE>;
 			pwr_active = <PWR_ACTIVE_HIGH>;
-			#rockchip,reset = <>;
-			#rst_active = <>;
-			#rockchip,flash = <>;
-			#rockchip,af = <>;
 			mir = <0>;
-			flash_attach = <0>;
-			resolution = <ov2659_FULL_RESOLUTION>;
-			powerup_sequence = <ov2659_PWRSEQ>;
+			flash_attach = <1>;
+			flash_active = <1>;
+			resolution = <adv7181_FULL_RESOLUTION>;
+			powerup_sequence = <adv7181_PWRSEQ>;
 			orientation = <0>;
-			i2c_add = <ov2659_I2C_ADDR>;
-			i2c_rata = <100000>;
-			i2c_chl = <0>;
-			cif_chl = <0>;
-			mclk_rate = <24>;
-		};
-		gc0329{
-			is_front = <1>;
-			rockchip,powerdown = <&gpio3 GPIO_D7 GPIO_ACTIVE_HIGH>;
-			pwdn_active = <gc0329_PWRDN_ACTIVE>;
-			#rockchip,power = <>;
-			pwr_active = <PWR_ACTIVE_HIGH>;
-			#rockchip,reset = <>;
-			#rst_active = <>;
-			#rockchip,flash = <>;
-			#rockchip,af = <>;
-			mir = <0>;
-			flash_attach = <0>;
-			resolution = <gc0329_FULL_RESOLUTION>;
-			powerup_sequence = <gc0329_PWRSEQ>;
-			orientation = <0>;
-			i2c_add = <gc0329_I2C_ADDR>;
-			i2c_rata = <100000>;
-			i2c_chl = <0>;
-			cif_chl = <0>;
-			mclk_rate = <24>;
-		};
-
-     gc2035{
-            is_front = <0>;
-            rockchip,power = <&gpio2 GPIO_B2 GPIO_ACTIVE_HIGH>;
-            rockchip,powerdown = <&gpio3 GPIO_B3 GPIO_ACTIVE_HIGH>;
-            pwdn_active = <gc2035_PWRDN_ACTIVE>;
-            pwr_active = <PWR_ACTIVE_HIGH>;
-            mir = <0>;
-            flash_attach = <0>;
-            resolution = <gc2035_FULL_RESOLUTION>;
-            powerup_sequence = <gc2035_PWRSEQ>;
-            orientation = <180>;
-            i2c_add = <gc2035_I2C_ADDR>;
-            i2c_rata = <100000>;
-            i2c_chl = <2>;
-            cif_chl = <0>;
-            mclk_rate = <24>;
-        };
-     gc0308{
-			is_front = <1>;
-			rockchip,power = <&gpio2 GPIO_B2 GPIO_ACTIVE_HIGH>;
-			rockchip,powerdown = <&gpio3 GPIO_D7 GPIO_ACTIVE_HIGH>;
-			pwdn_active = <gc0308_PWRDN_ACTIVE>;
-			pwr_active = <PWR_ACTIVE_HIGH>;
-			mir = <0>;
-			flash_attach = <0>;
-			resolution = <gc0308_FULL_RESOLUTION>;
-			powerup_sequence = <gc0308_PWRSEQ>;
-			orientation = <180>;
-			i2c_add = <gc0308_I2C_ADDR>;
+			i2c_add = <adv7181_I2C_ADDR>;
 			i2c_rata = <100000>;
 			i2c_chl = <2>;
 			cif_chl = <0>;
+			ad_chl = <0>; // 0 ~ 4;
 			mclk_rate = <24>;
+			rockchip,camera-module-defrect0 = <720 480 0 24 720 480>;
+			rockchip,camera-module-interface0 = "cvbs_ntsc";
+			rockchip,camera-module-defrect1 = <720 576 0 0 720 576>;
+			rockchip,camera-module-interface1 = "cvbs_pal";
+			rockchip,camera-module-channel = <4 0>;
+			rockchip,camera-module-ain-1 = "cvbs 1";
+			rockchip,camera-module-ain-2 = "cvbs 6";
+			rockchip,camera-module-ain-3 = "cvbs 8";
+			rockchip,camera-module-ain-4 = "cvbs 10";
+			rockchip,camera-module-ain-5 = "yprpb 6 8 10";
 		};
 
 	};
diff --git a/arch/arm/configs/px3se_linux_defconfig b/arch/arm/configs/px3se_linux_defconfig
index 1668f26..330f839 100644
--- a/arch/arm/configs/px3se_linux_defconfig
+++ b/arch/arm/configs/px3se_linux_defconfig
@@ -336,10 +336,9 @@ CONFIG_GS_MC3230=y
 # CONFIG_GS_LSM303D is not set
 # CONFIG_COMPASS_AK8975 is not set
 # CONFIG_GYROSCOPE_DEVICE is not set
-# CONFIG_HALL_DEVICE is not set
 CONFIG_PROXIMITY_DEVICE=y
 CONFIG_TEMPERATURE_DEVICE=y
-CONFIG_SENSORS_TMP103=y
+# CONFIG_HALL_DEVICE is not set
 CONFIG_ROCKCHIP_REMOTECTL=y
 CONFIG_ROCKCHIP_REMOTECTL_PWM=y
 CONFIG_SERIO_ROCKCHIP_PS2=y
@@ -376,6 +375,7 @@ CONFIG_POWER_RESET_GPIO=y
 CONFIG_POWER_AVS=y
 CONFIG_ROCKCHIP_IODOMAIN=y
 CONFIG_SENSORS_ROCKCHIP_TSADC=y
+CONFIG_SENSORS_TMP103=y
 CONFIG_THERMAL=y
 CONFIG_MFD_RT5025=y
 CONFIG_MISC_RT5025=y
@@ -428,6 +428,7 @@ CONFIG_BACKLIGHT_LCD_SUPPORT=y
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 # CONFIG_BACKLIGHT_GENERIC is not set
 CONFIG_BACKLIGHT_PWM=y
+CONFIG_VIDEO_REVERSE_IMAGE=y
 CONFIG_LCDC_RK3288=y
 CONFIG_LCDC_RK312X=y
 CONFIG_LCD_MIPI=y
@@ -440,7 +441,6 @@ CONFIG_RK32_MIPI_DSI=y
 CONFIG_RK_HDMI=y
 CONFIG_ROCKCHIP_RGA=y
 CONFIG_ROCKCHIP_RGA2=y
-# CONFIG_IEP is not set
 CONFIG_LOGO=y
 CONFIG_SOUND=y
 CONFIG_SND=y
@@ -454,10 +454,10 @@ CONFIG_SND_SOC=y
 CONFIG_SND_RK_SOC=y
 CONFIG_SND_RK_SOC_HDMI_I2S=y
 CONFIG_SND_RK_SOC_SPDIF_CARD=y
+CONFIG_SND_RK_SOC_ES8396=y
 CONFIG_SND_RK_SOC_NAU8540=y
 CONFIG_SND_RK_SOC_RK1000=y
 CONFIG_SND_RK_SOC_RK3036=y
-CONFIG_SND_RK_SOC_ES8396=y
 CONFIG_SND_RK_SOC_RK322X=y
 CONFIG_SND_RK_SOC_RT3224=y
 CONFIG_SND_RK_SOC_RT5631=y
diff --git a/drivers/media/video/rk30_camera_oneframe.c b/drivers/media/video/rk30_camera_oneframe.c
index b9cded3..18dafa1 100644
--- a/drivers/media/video/rk30_camera_oneframe.c
+++ b/drivers/media/video/rk30_camera_oneframe.c
@@ -1026,7 +1026,7 @@ static inline irqreturn_t rk_camera_cifirq(int irq, void *data)
 	if (pcdev->deinterlace)
 		reg_lastline = reg_lastline << 1;
 	
-    pcdev->irqinfo.cifirq_idx++;    
+    pcdev->irqinfo.cifirq_idx++;
     if ((reg_lastline != pcdev->host_height) /*|| (reg_lastpix != pcdev->host_width)*/) {
         pcdev->irqinfo.cifirq_abnormal_idx = pcdev->irqinfo.cifirq_idx;
         RKCAMERA_DG2("Cif irq-%ld is error, %dx%d != %dx%d\n",pcdev->irqinfo.cifirq_abnormal_idx,
@@ -3473,7 +3473,11 @@ static int rk_camera_init_async(void *unused)
     return 0;
 }
 
+#ifdef CONFIG_VIDEO_REVERSE_IMAGE
+int rk_camera_init(void)
+#else
 static int __init rk_camera_init(void)
+#endif
 {
 
 	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
@@ -3490,7 +3494,10 @@ static void __exit rk_camera_exit(void)
     platform_driver_unregister(&rk_camera_driver);
 }
 
+#ifndef CONFIG_VIDEO_REVERSE_IMAGE
 device_initcall_sync(rk_camera_init);
+#endif
+
 module_exit(rk_camera_exit);
 
 MODULE_DESCRIPTION("RKSoc Camera Host driver");
diff --git a/drivers/media/video/rk30_camera_pingpong.c b/drivers/media/video/rk30_camera_pingpong.c
index 52b17b3..ff827da 100644
--- a/drivers/media/video/rk30_camera_pingpong.c
+++ b/drivers/media/video/rk30_camera_pingpong.c
@@ -3522,7 +3522,11 @@ static int rk_camera_init_async(void *unused)
     return 0;
 }
 
+#ifdef CONFIG_VIDEO_REVERSE_IMAGE
+int rk_camera_init(void)
+#else
 static int __init rk_camera_init(void)
+#endif
 {
 
 	debug_printk( "/$$$$$$$$$$$$$$$$$$$$$$//n Here I am: %s:%i-------%s()\n", __FILE__, __LINE__,__FUNCTION__);
@@ -3539,7 +3543,9 @@ static void /* __exit */ rk_camera_exit(void)
     platform_driver_unregister(&rk_camera_driver);
 }
 
+#ifndef CONFIG_VIDEO_REVERSE_IMAGE
 device_initcall_sync(rk_camera_init);
+#endif
 module_exit(rk_camera_exit);
 
 MODULE_DESCRIPTION("RKSoc Camera Host driver");
diff --git a/drivers/misc/gpio-detection.c b/drivers/misc/gpio-detection.c
index c226401a4..bc9bf60 100644
--- a/drivers/misc/gpio-detection.c
+++ b/drivers/misc/gpio-detection.c
@@ -409,7 +409,11 @@ static struct platform_driver gpio_det_driver = {
 	.probe      = gpio_det_probe,
 };
 
+#ifdef CONFIG_VIDEO_REVERSE_IMAGE
+int gpio_det_init(void)
+#else
 static int __init gpio_det_init(void)
+#endif
 {
 	if (!gpio_deteciton_class_init())
 		return platform_driver_register(&gpio_det_driver);
@@ -417,8 +421,9 @@ static int __init gpio_det_init(void)
 		return -1;
 }
 
+#ifndef CONFIG_VIDEO_REVERSE_IMAGE
 fs_initcall_sync(gpio_det_init);
-
+#endif
 static void __exit gpio_det_exit(void)
 {
 	platform_driver_unregister(&gpio_det_driver);
diff --git a/drivers/video/rockchip/Kconfig b/drivers/video/rockchip/Kconfig
index 45061ea..923877b 100644
--- a/drivers/video/rockchip/Kconfig
+++ b/drivers/video/rockchip/Kconfig
@@ -67,6 +67,11 @@ config THREE_FB_BUFFER
         help
            select y if android support three buffer,like Jelly Bean
 
+config VIDEO_REVERSE_IMAGE
+    tristate "Support rk reverse image"
+    depends on I2C
+	help
+      supports reverse image
 
 source "drivers/video/rockchip/lcdc/Kconfig"
 source "drivers/video/rockchip/screen/Kconfig"
diff --git a/drivers/video/rockchip/Makefile b/drivers/video/rockchip/Makefile
index 9811e37..43f23bd 100755
--- a/drivers/video/rockchip/Makefile
+++ b/drivers/video/rockchip/Makefile
@@ -9,4 +9,5 @@ obj-$(CONFIG_RK_HDMI) += hdmi/
 obj-$(CONFIG_IEP) += iep/
 obj-$(CONFIG_RK_TVENCODER) += tve/
 obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += mpp/
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle/
 
diff --git a/drivers/video/rockchip/iep/iep.h b/drivers/video/rockchip/iep/iep.h
index 012b763..9c6f0fa 100644
--- a/drivers/video/rockchip/iep/iep.h
+++ b/drivers/video/rockchip/iep/iep.h
@@ -276,5 +276,7 @@ struct IEP_MSG {
 
 	void *base;
 };
+int iep_process_sync(struct IEP_MSG *msg);
+bool iep_device_ready(void);
 
 #endif
diff --git a/drivers/video/rockchip/iep/iep_drv.c b/drivers/video/rockchip/iep/iep_drv.c
old mode 100644
new mode 100755
index 3250017..afd67d4
--- a/drivers/video/rockchip/iep/iep_drv.c
+++ b/drivers/video/rockchip/iep/iep_drv.c
@@ -1357,7 +1357,11 @@ static void __exit iep_exit(void)
 	platform_driver_unregister(&iep_driver);
 }
 
+#ifdef CONFIG_VIDEO_REVERSE_IMAGE
+fs_initcall(iep_init);
+#else
 module_init(iep_init);
+#endif
 module_exit(iep_exit);
 
 /* Module information */
@@ -1365,6 +1369,67 @@ MODULE_AUTHOR("ljf@rock-chips.com");
 MODULE_DESCRIPTION("Driver for iep device");
 MODULE_LICENSE("GPL");
 
+bool iep_device_ready(void)
+{
+	return iep_service.iommu_dev ? true : false;
+}
+
+int iep_process_sync(struct IEP_MSG *msg)
+{
+	int ret = 0;
+	/*1. open*/
+	iep_session *session = (iep_session *)kzalloc(sizeof(iep_session),
+		GFP_KERNEL);
+	if (NULL == session) {
+		IEP_ERR("unable to allocate memory for iep_session.\n");
+		return -1;
+	}
+
+	if (!iep_service.iommu_dev)
+		return -1;
+
+	session->pid = current->pid;
+	INIT_LIST_HEAD(&session->waiting);
+	INIT_LIST_HEAD(&session->ready);
+	INIT_LIST_HEAD(&session->running);
+	INIT_LIST_HEAD(&session->list_session);
+	init_waitqueue_head(&session->wait);
+	/*add_wait_queue(&session->wait, wait);*/
+	/* no need to protect */
+	mutex_lock(&iep_service.lock);
+	list_add_tail(&session->list_session, &iep_service.session);
+	mutex_unlock(&iep_service.lock);
+	atomic_set(&session->task_running, 0);
+	atomic_set(&session->num_done, 0);
+
+#if defined(CONFIG_IEP_MMU)
+	rk_mmu_init_dte_table(session);
+	INIT_LIST_HEAD(&session->pte_list);
+#endif
+
+	/*2. req*/
+#if defined(CONFIG_IEP_IOMMU)
+	iep_power_on();
+#endif
+	iep_config(session, msg);
+
+	iep_try_set_reg();
+
+	if (0 > iep_get_result_sync(session)) {
+		IEP_INFO("%s failed, timeout\n", __func__);
+		ret = -ETIMEDOUT;
+	}
+
+	/*release*/
+	mutex_lock(&iep_service.lock);
+	list_del(&session->list_session);
+	iep_service_session_clear(session);
+	kfree(session);
+	mutex_unlock(&iep_service.lock);
+
+	return ret;
+}
+
 #ifdef IEP_TEST_CASE
 
 #include "yuv420sp_480x480_interlaced.h"
diff --git a/drivers/video/rockchip/lcdc/rk312x_lcdc.c b/drivers/video/rockchip/lcdc/rk312x_lcdc.c
index cd7168e..2e1e999 100755
--- a/drivers/video/rockchip/lcdc/rk312x_lcdc.c
+++ b/drivers/video/rockchip/lcdc/rk312x_lcdc.c
@@ -2304,8 +2304,57 @@ static ssize_t rk312x_lcdc_get_disp_info(struct rk_lcdc_driver *dev_drv,
 	if (lcdc_dev->clk_on) {
 		/* data format */
 		fmt_id = lcdc_readl(lcdc_dev, SYS_CTRL);
-		get_format_string((fmt_id & m_WIN0_FORMAT) >> 3, format_w0);
-		get_format_string((fmt_id & m_WIN1_FORMAT) >> 6, format_w1);
+
+		switch ((fmt_id & m_WIN0_FORMAT) >> 3) {
+		case 0:
+			strcpy(format_w0, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w0, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w0, "RGB565");
+			break;
+		case 4:
+			strcpy(format_w0, "YCbCr420");
+			break;
+		case 5:
+			strcpy(format_w0, "YCbCr422");
+			break;
+		case 6:
+			strcpy(format_w0, "YCbCr444");
+			break;
+		default:
+			strcpy(format_w0, "invalid\n");
+			break;
+		}
+
+		switch ((fmt_id & m_WIN1_FORMAT) >> 6) {
+		case 0:
+			strcpy(format_w1, "ARGB888");
+			break;
+		case 1:
+			strcpy(format_w1, "RGB888");
+			break;
+		case 2:
+			strcpy(format_w1, "RGB565");
+			break;
+		case 4:
+			strcpy(format_w1, "8bpp");
+			break;
+		case 5:
+			strcpy(format_w1, "4bpp");
+			break;
+		case 6:
+			strcpy(format_w1, "2bpp");
+			break;
+		case 7:
+			strcpy(format_w1, "1bpp");
+			break;
+		default:
+			strcpy(format_w1, "invalid\n");
+			break;
+		}
 
 		/* win status */
 		if (fmt_id & m_WIN0_EN)
diff --git a/drivers/video/rockchip/rga2/rga2_drv.c b/drivers/video/rockchip/rga2/rga2_drv.c
index d5508d9..8563475 100644
--- a/drivers/video/rockchip/rga2/rga2_drv.c
+++ b/drivers/video/rockchip/rga2/rga2_drv.c
@@ -1092,6 +1092,12 @@ long rga2_ioctl_kernel(struct rga_req *req_rga)
 	}
 
 	RGA_MSG_2_RGA2_MSG(req_rga, &req);
+
+	if (first_RGA2_proc == 0) {
+		ret = rga2_prepare(session);
+		first_RGA2_proc = 1;
+	}
+
 	ret = rga2_blit_sync(session, &req);
 
 	mutex_unlock(&rga2_service.mutex);
diff --git a/drivers/video/rockchip/rk_drm_fb.c b/drivers/video/rockchip/rk_drm_fb.c
index 2b3756f..4dd2c05 100755
--- a/drivers/video/rockchip/rk_drm_fb.c
+++ b/drivers/video/rockchip/rk_drm_fb.c
@@ -53,6 +53,283 @@ static struct rk_display_device *disp_hdmi_devices;
 static struct rk_lcdc_driver *prm_dev_drv;
 static struct rk_lcdc_driver *ext_dev_drv;
 
+static struct rk_lcdc_driver *rk_get_prmry_lcdc_drv(void);
+static struct rk_fb_car_par car_par;
+
+static int is_car_reversing(void)
+{
+	return car_par.car_reversing;
+}
+
+static int rk_fb_init_car_par(struct rk_lcdc_driver *dev_drv)
+{
+	car_par.fb_inited = true;
+	car_par.logo_showing = dev_drv->uboot_logo;
+	car_par.screen_width = dev_drv->screen0->mode.xres;
+	car_par.screen_height = dev_drv->screen0->mode.yres;
+	car_par.dev = dev_drv->dev;
+	car_par.iommu_enabled = dev_drv->iommu_enabled;
+	return 0;
+}
+
+struct rk_fb_car_par *rk_fb_get_car_par(void)
+{
+	return &car_par;
+}
+int rk_fb_show_backup(void);
+int rk_set_car_reverse(bool reversing)
+{
+	struct rk_lcdc_driver *dev_drv;
+
+	if (!car_par.fb_inited) {
+		car_par.car_reversing = reversing;
+		pr_info("%s, car_par not inited,return\n", __func__);
+		return -1;
+	}
+
+	dev_drv = rk_get_prmry_lcdc_drv();
+
+	if (reversing) {
+		pr_info("%s, reverse enter\n", __func__);
+		rk_fb_set_car_reverse_status(dev_drv, 1);
+	} else {
+		pr_info("%s, reverse exit\n", __func__);
+		rk_fb_set_car_reverse_status(dev_drv, 0);
+		rk_fb_show_backup();
+	}
+	return 0;
+}
+
+void rk_direct_fb_show(struct fb_info *fbi)
+{
+}
+EXPORT_SYMBOL(rk_direct_fb_show);
+
+int rk_fb_dpi_open(bool open)
+{
+	return 0;
+}
+
+int rk_fb_dpi_win_sel(int win_id)
+{
+	return 0;
+}
+static int rk_drm_win_commit(struct rk_drm_display *drm_disp,
+			     unsigned int win_id);
+static int rk_drm_display_commit(struct rk_drm_display *drm_disp);
+int rk_fb_show_backup(void)
+{
+    struct rk_drm_display *drm_disp = rk_drm_get_diplay(RK_DRM_PRIMARY_SCREEN);
+
+    rk_drm_win_commit(drm_disp, 1);
+    rk_drm_display_commit(drm_disp);
+    return 0;
+}
+
+static int rk_fb_data_fmt(int data_format, int bits_per_pixel)
+{
+	int fb_data_fmt = 0;
+
+	if (data_format) {
+		switch (data_format) {
+		case HAL_PIXEL_FORMAT_RGBX_8888:
+			fb_data_fmt = XBGR888;
+			break;
+		case HAL_PIXEL_FORMAT_BGRX_8888:
+			fb_data_fmt = XRGB888;
+			break;
+		case HAL_PIXEL_FORMAT_RGBA_8888:
+			fb_data_fmt = ABGR888;
+			break;
+		case HAL_PIXEL_FORMAT_BGRA_8888:
+			fb_data_fmt = ARGB888;
+			break;
+		case HAL_PIXEL_FORMAT_RGB_888:
+			fb_data_fmt = RGB888;
+			break;
+		case HAL_PIXEL_FORMAT_BGR_888:
+			fb_data_fmt = BGR888;
+			break;
+		case HAL_PIXEL_FORMAT_RGB_565:
+			fb_data_fmt = RGB565;
+			break;
+		case HAL_PIXEL_FORMAT_BGR_565:
+			fb_data_fmt = BGR565;
+			break;
+		case HAL_PIXEL_FORMAT_YCbCr_422_SP:	/* yuv422 */
+			fb_data_fmt = YUV422;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_420_SP:	/* YUV420---vuvuvu */
+			fb_data_fmt = YUV420_NV21;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_NV12:	/* YUV420---uvuvuv */
+			fb_data_fmt = YUV420;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_444:	/* yuv444 */
+			fb_data_fmt = YUV444;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_NV12_10:	/* yuv444 */
+			fb_data_fmt = YUV420_A;
+			break;
+		case HAL_PIXEL_FORMAT_YCbCr_422_SP_10:	/* yuv444 */
+			fb_data_fmt = YUV422_A;
+			break;
+		case HAL_PIXEL_FORMAT_YCrCb_444_SP_10:	/* yuv444 */
+			fb_data_fmt = YUV444_A;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_RGB565:	/* fbdc rgb565*/
+			fb_data_fmt = FBDC_RGB_565;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_U8U8U8U8:	/* fbdc argb888 */
+			fb_data_fmt = FBDC_ARGB_888;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_RGBA888:	/* fbdc abgr888 */
+			fb_data_fmt = FBDC_ABGR_888;
+			break;
+		case HAL_PIXEL_FORMAT_FBDC_U8U8U8:	/* fbdc rgb888 */
+			fb_data_fmt = FBDC_RGBX_888;
+			break;
+		case HAL_PIXEL_FORMAT_YUYV422:		/* yuyv422 */
+			fb_data_fmt = YUYV422;
+			break;
+		case HAL_PIXEL_FORMAT_YUYV420:		/* yuyv420 */
+			fb_data_fmt = YUYV420;
+			break;
+		case HAL_PIXEL_FORMAT_UYVY422:		/* uyvy422 */
+			fb_data_fmt = UYVY422;
+			break;
+		case HAL_PIXEL_FORMAT_UYVY420:		/* uyvy420 */
+			fb_data_fmt = UYVY420;
+			break;
+		default:
+			pr_warn("%s: unsupported format: 0x%x\n",
+				__func__, data_format);
+			return -EINVAL;
+		}
+	} else {
+		switch (bits_per_pixel) {
+		case 32:
+			fb_data_fmt = ARGB888;
+			break;
+		case 24:
+			fb_data_fmt = RGB888;
+			break;
+		case 16:
+			fb_data_fmt = RGB565;
+			break;
+		default:
+			pr_warn("%s: unsupported bits_per_pixel: %d\n",
+				__func__, bits_per_pixel);
+			break;
+		}
+	}
+	return fb_data_fmt;
+}
+
+int rk_set_dsp(int cmd, unsigned long arg)
+{
+	struct rk_drm_display *drm_disp = rk_drm_get_diplay(RK_DRM_PRIMARY_SCREEN);
+	struct rk_drm_screen_private *drm_screen_priv =
+      container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
+	struct rk_lcdc_driver *dev_drv = drm_screen_priv->lcdc_dev_drv;
+
+	int ret;
+	struct rk_fb_win_cfg_data *fb_info = (struct rk_fb_win_cfg_data *)arg;
+	struct rk_fb_win_par *win_par = &fb_info->win_par[0];
+
+	if (!car_par.fb_inited) {
+		pr_info("%s, car_par not inited,return\n", __func__);
+		return -1;
+	}
+
+	fb_info = (struct rk_fb_win_cfg_data *)arg;
+    if (fb_info) {
+    int j = 0;
+    struct rk_win_data win_data;
+    struct rk_win_data *rk_win = &win_data, *drm_win;
+    struct rk_lcdc_win *lcdc_win = dev_drv->win[j];
+
+    rk_win->format = rk_fb_data_fmt(win_par->area_par[0].data_format, 0);
+    rk_win->xpos = win_par->area_par[0].x_offset;
+    rk_win->ypos = win_par->area_par[0].y_offset;
+    rk_win->xact = win_par->area_par[0].xact;
+    rk_win->yact = win_par->area_par[0].yact;
+    rk_win->xsize = win_par->area_par[0].xsize;
+    rk_win->ysize = win_par->area_par[0].ysize;
+    rk_win->xvir = win_par->area_par[0].xvir;
+    rk_win->yvir = win_par->area_par[0].yvir;
+    rk_win->yrgb_addr = win_par->area_par[0].phy_addr;
+    rk_win->enabled = true;
+    if (rk_win->format == YUV420 || rk_win->format == YUV422) {
+      rk_win->uv_addr = rk_win->yrgb_addr + rk_win->xvir * rk_win->yvir;
+      rk_win->xvir /= 4;
+      rk_win->uv_vir = rk_win->xvir;
+    }
+
+    drm_win = rk_win;
+    lcdc_win->area[0].format = drm_win->format;
+    lcdc_win->area[0].xpos = drm_win->xpos;
+    lcdc_win->area[0].ypos = drm_win->ypos;
+    lcdc_win->area[0].xsize = drm_win->xsize;
+    lcdc_win->area[0].ysize = drm_win->ysize;
+    lcdc_win->area[0].xact = drm_win->xact;
+    lcdc_win->area[0].yact = drm_win->yact;
+    lcdc_win->area[0].xvir = drm_win->xvir;
+    lcdc_win->area[0].y_vir_stride = drm_win->xvir;
+    lcdc_win->area[0].uv_vir_stride = drm_win->uv_vir;
+    lcdc_win->area[0].smem_start = drm_win->yrgb_addr;
+    lcdc_win->area[0].cbr_start = drm_win->uv_addr;
+    lcdc_win->alpha_en = 1;
+    if (lcdc_win->state != drm_win->enabled) {
+      pr_info("%s[%d], win:%d, drm_win->enabled:%d, lcdc_win->state:%d\n",
+        __func__, __LINE__, j, drm_win->enabled, lcdc_win->state);
+      dev_drv->ops->open(dev_drv, j, drm_win->enabled ? true : false);
+    }
+
+    dev_drv->ops->set_par(dev_drv, j);
+    dev_drv->ops->pan_display(dev_drv, j);
+
+	if (dev_drv->ops->lcdc_reg_update)
+		dev_drv->ops->lcdc_reg_update(dev_drv);
+	if (dev_drv->ops->cfg_done)
+		dev_drv->ops->cfg_done(dev_drv);
+  }
+  return ret;
+}
+
+
+static ssize_t show_disp_info(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct rk_drm_private *rk_drm_priv = platform_get_drvdata(drm_fb_pdev);
+	struct rk_lcdc_driver *dev_drv =
+			rk_drm_priv->screen_priv[0].lcdc_dev_drv;
+
+	if (dev_drv->ops->get_disp_info)
+		return dev_drv->ops->get_disp_info(dev_drv, buf, 0);
+
+	return 0;
+}
+
+static struct device_attribute rk_drm_fb_attrs[] = {
+	__ATTR(disp_info, S_IRUGO, show_disp_info, NULL),
+};
+
+int rk_drm_fb_create_sysfs(struct rk_lcdc_driver *dev_drv)
+{
+	int r, t;
+
+	for (t = 0; t < ARRAY_SIZE(rk_drm_fb_attrs); t++) {
+		r = device_create_file(dev_drv->dev, &rk_drm_fb_attrs[t]);
+		if (r) {
+			dev_err(dev_drv->dev, "failed to create sysfs " "file\n");
+			return r;
+		}
+	}
+
+	return 0;
+}
+
 void rk_drm_display_register(struct rk_display_ops *extend_ops,
 			     void *displaydata, int type)
 {
@@ -883,16 +1160,21 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 					    struct fb_modelist, list);
 		mode = &modelist->mode;
 
+		rk_drm_fb_create_sysfs(dev_drv);
+
 		if (dev_drv->ops->open)
 			dev_drv->ops->open(dev_drv, 0, 1);
 		if (dev_drv->ops->mmu_en)
 			dev_drv->ops->mmu_en(dev_drv);
+
+		rk_fb_init_car_par(dev_drv);
 	} else if (dev_drv->prop == EXTEND) {
 		/* struct list_head *modelist;*/
 		ext_dev_drv = dev_drv;
 		drm_screen_priv->ex_display = rk_drm_extend_display_get(SCREEN_HDMI);
 		drm_display->screen_type = RK_DRM_EXTEND_SCREEN;
 		drm_display->is_connected = 0;
+
 #if 0
 		drm_screen_priv->ex_display->ops->getmodelist(drm_screen_priv->ex_display, &modelist);
 		memcpy(&drm_display->modelist, modelist, sizeof(struct list_head));
@@ -1093,6 +1375,7 @@ static int rk_drm_win_commit(struct rk_drm_display *drm_disp,
 			lcdc_win->area[0].yact = drm_win->yact;
 			lcdc_win->area[0].xvir = drm_win->xvir;
 			lcdc_win->area[0].y_vir_stride = drm_win->xvir;
+			lcdc_win->area[0].uv_vir_stride = drm_win->uv_vir;
 			lcdc_win->area[0].smem_start = drm_win->yrgb_addr;
 			lcdc_win->area[0].cbr_start = drm_win->uv_addr;
 			lcdc_win->alpha_en = 1;
@@ -1101,6 +1384,7 @@ static int rk_drm_win_commit(struct rk_drm_display *drm_disp,
 					__func__, __LINE__, j, drm_win->enabled, lcdc_win->state);
 				dev_drv->ops->open(dev_drv, j, drm_win->enabled ? true : false);
 			}
+
 			dev_drv->ops->set_par(dev_drv, j);
 			dev_drv->ops->pan_display(dev_drv, j);
 		}
@@ -1129,6 +1413,11 @@ int rk_drm_disp_handle(struct rk_drm_display *drm_disp, unsigned int win_id,
 		container_of(drm_disp, struct rk_drm_screen_private, drm_disp);
 	int i = 0;
 
+   if (drm_screen_priv->lcdc_dev_drv->prop ==  PRMRY &&
+        win_id == 1 && is_car_reversing()) {
+        return 0;
+   }
+
 	for (i = 1; i < RK_DRM_CMD_MASK; i = i << 1) {
 		switch (i&cmd_id) {
 		case RK_DRM_SCREEN_SET:
@@ -1174,9 +1463,18 @@ struct rk_drm_display *rk_drm_get_diplay(int screen_type)
 int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv,
 				 int status)
 {
-	return 0;
+  if (status) {
+    car_par.car_reversing = 1;
+    pr_debug("%s: camcap reverse start...\n", __func__);
+  } else {
+    car_par.car_reversing = 0;
+    pr_debug("%s: camcap reverse finish...\n", __func__);
+  }
+
+  return 0;
 }
 
+
 static int rk_drm_fb_probe(struct platform_device *pdev)
 {
 	struct rk_drm_private  *rk_drm_priv = NULL;
diff --git a/drivers/video/rockchip/rk_drm_fb.h b/drivers/video/rockchip/rk_drm_fb.h
index 52367f0..c4cd1cf 100755
--- a/drivers/video/rockchip/rk_drm_fb.h
+++ b/drivers/video/rockchip/rk_drm_fb.h
@@ -26,6 +26,8 @@ struct rk_win_data {
 	unsigned int		xsize;
 	unsigned int		ysize;
 	unsigned int 		xvir;
+	unsigned int    yvir;
+	unsigned int    uv_vir;
 
 	dma_addr_t		yrgb_addr;
 	dma_addr_t		uv_addr;
diff --git a/drivers/video/rockchip/rk_fb.c b/drivers/video/rockchip/rk_fb.c
old mode 100644
new mode 100755
index 7dc4da7..3158022
--- a/drivers/video/rockchip/rk_fb.c
+++ b/drivers/video/rockchip/rk_fb.c
@@ -88,10 +88,11 @@ module_param(rk_fb_iommu_debug, int, S_IRUGO | S_IWUSR);
 static int rk_fb_config_debug(struct rk_lcdc_driver *dev_drv,
 			      struct rk_fb_win_cfg_data *win_data,
 			      struct rk_fb_reg_data *regs, u32 cmd);
-static int car_reversing;
+static struct rk_lcdc_driver *rk_get_prmry_lcdc_drv(void);
+static struct rk_fb_car_par car_par;
 
 static int is_car_camcap(void) {
-	return car_reversing && strcmp("camcap", current->comm);
+	return car_par.car_reversing && strcmp("camcap", current->comm);
 }
 
 int support_uboot_display(void)
@@ -99,6 +100,41 @@ int support_uboot_display(void)
 	return uboot_logo_on;
 }
 
+static int rk_fb_init_car_par(struct rk_lcdc_driver *dev_drv)
+{
+	car_par.fb_inited = true;
+	car_par.logo_showing = dev_drv->uboot_logo;
+	car_par.screen_width = dev_drv->screen0->mode.xres;
+	car_par.screen_height = dev_drv->screen0->mode.yres;
+	return 0;
+}
+
+struct rk_fb_car_par *rk_fb_get_car_par(void)
+{
+	return &car_par;
+}
+
+int rk_set_car_reverse(bool reversing)
+{
+	struct rk_lcdc_driver *dev_drv;
+
+	if (!car_par.fb_inited) {
+		car_par.car_reversing = reversing;
+		pr_info("%s, car_par not inited,return\n", __func__);
+		return -1;
+	}
+
+	dev_drv = rk_get_prmry_lcdc_drv();
+
+	if (reversing) {
+		rk_fb_set_car_reverse_status(dev_drv, 1);
+	} else {
+		pr_info("%s, reverse exit\n", __func__);
+		rk_fb_set_car_reverse_status(dev_drv, 0);
+	}
+	return 0;
+}
+
 int rk_fb_get_display_policy(void)
 {
 	struct rk_fb *rk_fb;
@@ -1407,8 +1443,8 @@ static int rk_fb_pan_display(struct fb_var_screeninfo *var,
 	u16 uv_x_off, uv_y_off, uv_y_act;
 	u8 is_pic_yuv = 0;
 
-	if (dev_drv->suspend_flag || is_car_camcap())
-		return 0;
+	//if (dev_drv->suspend_flag || is_car_camcap())
+		//return 0;
 	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
 	if (win_id < 0)
 		return -ENODEV;
@@ -3029,6 +3065,7 @@ static int rk_fb_ioctl(struct fb_info *info, unsigned int cmd,
 			if (cfgdone_index >= 10)
 				cfgdone_index = 0;
 		}
+		car_par.logo_showing = 0;
 		if (is_car_camcap()) {
 			int i = 0;
 
@@ -3060,6 +3097,34 @@ cam_exit:
 			dev_drv->uboot_logo = 0;
 
 		break;
+	case RK_FBIOSET_CAR_CONFIG_DONE:
+		{
+			int curr = 0;
+			struct timespec now;
+
+			getnstimeofday(&now);
+			curr = now.tv_sec * 1000000 + now.tv_nsec / 1000;
+			cfgdone_distlist[cfgdone_index++] =
+				curr - cfgdone_lasttime;
+			cfgdone_lasttime = curr;
+			if (cfgdone_index >= 10)
+				cfgdone_index = 0;
+		}
+
+		memcpy(&win_data, (struct rk_fb_win_cfg_data __user *)argp,
+		       sizeof(win_data));
+
+		dev_drv->wait_fs = win_data.wait_fs;
+		ret = rk_fb_set_win_config(info, &win_data);
+
+		memcpy((struct rk_fb_win_cfg_data __user *)arg,
+		       &win_data, sizeof(win_data));
+		memset(&win_data, 0, sizeof(struct rk_fb_win_cfg_data));
+
+		if (dev_drv->uboot_logo)
+			dev_drv->uboot_logo = 0;
+
+		break;
 	default:
 		dev_drv->ops->ioctl(dev_drv, cmd, arg, win_id);
 		break;
@@ -3078,7 +3143,9 @@ static int rk_fb_blank(int blank_mode, struct fb_info *info)
 	struct rk_fb *rk_fb = dev_get_drvdata(info->device);
 #endif
 
-	if (car_reversing && strcmp("camcap", current->comm))
+	if (FB_BLANK_UNBLANK != blank_mode &&
+	    car_par.car_reversing &&
+	    strcmp("camcap", current->comm))
 		return 0;
 	win_id = dev_drv->ops->fb_get_win_id(dev_drv, fix->id);
 	if (win_id < 0)
@@ -3291,8 +3358,8 @@ static int rk_fb_set_par(struct fb_info *info)
 	u16 uv_x_off, uv_y_off, uv_y_act;
 	u8 is_pic_yuv = 0;
 	/*var->pixclock = dev_drv->pixclock;*/
-	if (dev_drv->suspend_flag || is_car_camcap())
-		return 0;
+	//if (dev_drv->suspend_flag || is_car_camcap())
+		//return 0;
 	win_id = dev_drv->ops->fb_get_win_id(dev_drv, info->fix.id);
 	if (win_id < 0)
 		return -ENODEV;
@@ -4448,6 +4515,12 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 					width, height, xvir,
 					ymirror);
 			}
+			car_par.direct_show.rgb_mst = main_fbi->fix.smem_start;
+			car_par.direct_show.format = rk_fb_data_fmt(0, bits);
+			car_par.direct_show.xact = width;
+			car_par.direct_show.yact = height;
+			car_par.direct_show.xvir = xvir;
+			car_par.direct_show.ymirror = ymirror;
 			if (dev_drv->iommu_enabled) {
 				rk_fb_poll_wait_frame_complete();
 				if (dev_drv->ops->mmu_en)
@@ -4455,6 +4528,7 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 				freed_index = 0;
 			}
 			local_irq_restore(flags);
+			rk_fb_init_car_par(dev_drv);
 			return 0;
 		} else if (dev_drv->uboot_logo && uboot_logo_base) {
 			u32 start = uboot_logo_base;
@@ -4515,6 +4589,13 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 					format,	xact, yact,
 					xvir,
 					y_mirror);
+			car_par.direct_show.rgb_mst = main_fbi->fix.smem_start +
+						(y_mirror ? logo_len : 0);
+			car_par.direct_show.format = format;
+			car_par.direct_show.xact = xact;
+			car_par.direct_show.yact = yact;
+			car_par.direct_show.xvir = xvir;
+			car_par.direct_show.ymirror = y_mirror;
 			if (dev_drv->iommu_enabled) {
 				rk_fb_poll_wait_frame_complete();
 				if (dev_drv->ops->mmu_en)
@@ -4522,6 +4603,7 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 				freed_index = 0;
 			}
 			local_irq_restore(flags);
+			rk_fb_init_car_par(dev_drv);
 			return 0;
 		} else {
 			if (dev_drv->iommu_enabled) {
@@ -4545,6 +4627,8 @@ int rk_fb_register(struct rk_lcdc_driver *dev_drv,
 #endif
 		main_fbi->fbops->fb_pan_display(&main_fbi->var, main_fbi);
 #endif
+
+		rk_fb_init_car_par(dev_drv);
 	} else {
 		struct fb_info *extend_fbi = rk_fb->fb[dev_drv->fb_index_base];
 
@@ -4592,10 +4676,10 @@ int rk_fb_unregister(struct rk_lcdc_driver *dev_drv)
 int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv,
 				 int status)
 {
-	char *envp[3] = {"Request", "FORCE UPDATE", NULL};
+	char *envp[3] = {"switch screen", "SCREEN=-1,ENABLE=-1", NULL};
 
 	if (status) {
-		car_reversing = 1;
+		car_par.car_reversing = 1;
 		flush_kthread_worker(&dev_drv->update_regs_worker);
 		dev_drv->timeline_max++;
 #ifdef H_USE_FENCE
@@ -4603,7 +4687,7 @@ int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv,
 #endif
 		pr_debug("%s: camcap reverse start...\n", __func__);
 	} else {
-		car_reversing = 0;
+		car_par.car_reversing = 0;
 		kobject_uevent_env(&dev_drv->dev->kobj,
 				   KOBJ_CHANGE, envp);
 		pr_debug("%s: camcap reverse finish...\n", __func__);
@@ -4612,6 +4696,29 @@ int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv,
 	return 0;
 }
 
+int rk_set_dsp(int cmd, unsigned long arg)
+{
+	struct rk_fb *inf = NULL;
+	struct fb_info *fbi = NULL;
+	int ret;
+
+	if (!car_par.fb_inited) {
+		pr_info("%s, car_par not inited,return\n", __func__);
+		return -1;
+	}
+
+	if (likely(fb_pdev))
+		inf = platform_get_drvdata(fb_pdev);
+	else
+		return -1;
+
+	fbi = inf->fb[0];
+
+	ret = fbi->fbops->fb_ioctl(fbi, cmd, arg);
+	return ret;
+}
+
+
 static int rk_fb_probe(struct platform_device *pdev)
 {
 	struct rk_fb *rk_fb = NULL;
diff --git a/drivers/video/rockchip/vehicle/Makefile b/drivers/video/rockchip/vehicle/Makefile
new file mode 100644
index 0000000..841a457
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/Makefile
@@ -0,0 +1,8 @@
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_flinger.o
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_dev.o
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_main.o
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_cif.o
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_ad_tp2825.o
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_generic_sensor.o
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_ad_7181.o
+obj-$(CONFIG_VIDEO_REVERSE_IMAGE) += vehicle_gpio.o
diff --git a/drivers/video/rockchip/vehicle/flinger.h b/drivers/video/rockchip/vehicle/flinger.h
new file mode 100644
index 0000000..42d09b9
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/flinger.h
@@ -0,0 +1,41 @@
+/*
+ * drivers/video/rockchip/flinger/flinger.c
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co.Ltd
+ * Authors:
+ *      Zhiqin Wei <wzq@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "vehicle_cfg.h"
+
+#ifndef _drivers_video_rockchip_flinger_h_
+#define _drivers_video_rockchip_flinger_h_
+
+int rk_flinger_init(struct device *dev);
+int rk_flinger_deinit(void);
+int rk_flinger_reverse_open(struct vehicle_cfg *cfg);
+int rk_flinger_reverse_exit(void);
+void rk_flinger_message_handler(int size, const void *mssg);
+
+enum {
+	RGA_TRANSFORM_ROT_MASK   =   0x0000000F,
+	RGA_TRANSFORM_ROT_0      =   0x00000000,
+	RGA_TRANSFORM_ROT_90     =   0x00000001,
+	RGA_TRANSFORM_ROT_180    =   0x00000002,
+	RGA_TRANSFORM_ROT_270    =   0x00000004,
+
+	RGA_TRANSFORM_FLIP_MASK  =   0x000000F0,
+	RGA_TRANSFORM_FLIP_H     =   0x00000020,
+	RGA_TRANSFORM_FLIP_V     =   0x00000010,
+};
+#endif
diff --git a/drivers/video/rockchip/vehicle/vehicle_ad.h b/drivers/video/rockchip/vehicle/vehicle_ad.h
new file mode 100644
index 0000000..5748f12
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_ad.h
@@ -0,0 +1,65 @@
+#ifndef __AD_COMMON_H
+#define __AD_COMMON_H
+#include <linux/i2c.h>
+#include "vehicle_cfg.h"
+
+enum vehicle_ad_fix_format {
+	AD_FIX_FORMAT_AUTO_DETECT = 0,
+	AD_FIX_FORMAT_PAL = 1,
+	AD_FIX_FORMAT_NTSC = 2,
+	AD_FIX_FORMAT_720P_50FPS = 3,
+	AD_FIX_FORMAT_720P_30FPS = 4,
+	AD_FIX_FORMAT_720P_25FPS = 5,
+};
+
+struct vehicle_camera_device_defrect {
+	unsigned int width;
+	unsigned int height;
+	unsigned int crop_x;
+	unsigned int crop_y;
+	unsigned int crop_width;
+	unsigned int crop_height;
+	const char *interface;
+};
+
+struct vehicle_state_check_work {
+	struct workqueue_struct *state_check_wq;
+	struct delayed_work work;
+};
+
+struct ad_dev {
+	struct device *dev;
+	struct i2c_adapter *adapter;
+	const char *ad_name;
+	int resolution;
+	int mclk_rate;
+	int ad_chl;
+	int i2c_chl;
+	int i2c_add;
+	int i2c_rate;
+	int powerdown;
+	int pwdn_active;
+	int power;
+	int pwr_active;
+	int reset;
+	int rst_active;
+	int cvstd;
+	int cvstd_irq_flag;
+	int irq;
+	int fix_format;
+	struct vehicle_camera_device_defrect defrects[4];
+	struct vehicle_state_check_work	state_check_work;
+	struct vehicle_cfg cfg;
+	int cif_error_last_line;
+};
+
+int vehicle_generic_sensor_write(struct ad_dev *ad, char reg, char *pval);
+int vehicle_generic_sensor_read(struct ad_dev *ad, char reg);
+int vehicle_parse_sensor(struct ad_dev *ad);
+
+int vehicle_ad_init(struct ad_dev *ad);
+int vehicle_ad_deinit(void);
+struct vehicle_cfg *ad_get_vehicle_cfg(void);
+void ad_check_cif_error(struct ad_dev *ad, int last_line);
+
+#endif
diff --git a/drivers/video/rockchip/vehicle/vehicle_ad_7181.c b/drivers/video/rockchip/vehicle/vehicle_ad_7181.c
new file mode 100755
index 0000000..b94ca83
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_ad_7181.c
@@ -0,0 +1,421 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/sysctl.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/uaccess.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/videodev2.h>
+#include "vehicle_cfg.h"
+#include "vehicle_main.h"
+#include "vehicle_ad.h"
+#include "vehicle_ad_7181.h"
+
+enum {
+	FORCE_PAL_WIDTH = 720,
+	FORCE_PAL_HEIGHT = 576,
+	FORCE_NTSC_WIDTH = 720,
+	FORCE_NTSC_HEIGHT = 480,
+	FORCE_CIF_OUTPUT_FORMAT = CIF_OUTPUT_FORMAT_422,
+};
+
+static v4l2_std_id std_old = V4L2_STD_NTSC;
+
+#define SENSOR_REGISTER_LEN	1	/* sensor register address bytes*/
+#define SENSOR_VALUE_LEN	1	/* sensor register value bytes*/
+
+#define ADV7181_SENSOR_BUS_PARAM	(V4L2_MBUS_MASTER |     \
+                    V4L2_MBUS_PCLK_SAMPLE_RISING |  \
+                    V4L2_MBUS_HSYNC_ACTIVE_HIGH |   \
+                    V4L2_MBUS_VSYNC_ACTIVE_HIGH |   \
+                    V4L2_MBUS_DATA_ACTIVE_HIGH |    \
+                    SOCAM_MCLK_24MHZ)
+struct rk_sensor_reg {
+	unsigned int reg;
+	unsigned int val;
+};
+
+#define ADV7181_STATUS1_REG		0x10
+#define ADV7181_STATUS1_IN_LOCK		0x01
+#define ADV7181_STATUS1_AUTOD_MASK	0x70
+#define ADV7181_STATUS1_AUTOD_NTSM_M_J	0x00
+#define ADV7181_STATUS1_AUTOD_NTSC_4_43 0x10
+#define ADV7181_STATUS1_AUTOD_PAL_M	0x20
+#define ADV7181_STATUS1_AUTOD_PAL_60	0x30
+#define ADV7181_STATUS1_AUTOD_PAL_B_G	0x40
+#define ADV7181_STATUS1_AUTOD_SECAM	0x50
+#define ADV7181_STATUS1_AUTOD_PAL_COMB	0x60
+#define ADV7181_STATUS1_AUTOD_SECAM_525	0x70
+
+#define ADV7181_INPUT_CONTROL		0x00
+#define ADV7181_INPUT_DEFAULT		0x00
+#define ADV7181_INPUT_CVBS_AIN2		0x00
+#define ADV7181_INPUT_CVBS_AIN3		0x01
+#define ADV7181_INPUT_CVBS_AIN5		0x02
+#define ADV7181_INPUT_CVBS_AIN6		0x03
+#define ADV7181_INPUT_CVBS_AIN8		0x04
+#define ADV7181_INPUT_CVBS_AIN10	0x05
+#define ADV7181_INPUT_CVBS_AIN1		0x0B
+#define ADV7181_INPUT_CVBS_AIN4		0x0D
+#define ADV7181_INPUT_CVBS_AIN7		0x0F
+
+#define SEQCMD_END  0xFF000000
+#define SensorEnd   {SEQCMD_END, 0x00}
+
+#define SENSOR_DG DBG
+#define SENSOR_TR DBG
+
+/* Preview resolution setting*/
+static struct rk_sensor_reg sensor_preview_data[] = {
+	/* autodetect cvbs in ntsc/pal/secam 8-bit 422 encode */
+	{0x00, 0x0B}, /*cvbs in AIN1*/
+	{0x04, 0x77},
+	{0x17, 0x41},
+	{0x1D, 0x47},
+	{0x31, 0x02},
+	{0x3A, 0x17},
+	{0x3B, 0x81},
+	{0x3D, 0xA2},
+	{0x3E, 0x6A},
+	{0x3F, 0xA0},
+	{0x86, 0x0B},
+	{0xF3, 0x01},
+	{0xF9, 0x03},
+	{0x0E, 0x80},
+	{0x52, 0x46},
+	{0x54, 0x80},
+	{0x7F, 0xFF},
+	{0x81, 0x30},
+	{0x90, 0xC9},
+	{0x91, 0x40},
+	{0x92, 0x3C},
+	{0x93, 0xCA},
+	{0x94, 0xD5},
+	{0xB1, 0xFF},
+	{0xB6, 0x08},
+	{0xC0, 0x9A},
+	{0xCF, 0x50},
+	{0xD0, 0x4E},
+	{0xD1, 0xB9},
+	{0xD6, 0xDD},
+	{0xD7, 0xE2},
+	{0xE5, 0x51},
+	{0xF6, 0x3B},
+	{0x0E, 0x00},
+	{0x03, 0x0C},
+	SensorEnd
+};
+
+static v4l2_std_id adv7181_std_to_v4l2(u8 status1)
+{
+	/* in case V4L2_IN_ST_NO_SIGNAL */
+	if (!(status1 & ADV7181_STATUS1_IN_LOCK))
+		return V4L2_STD_UNKNOWN;
+
+	switch (status1 & ADV7181_STATUS1_AUTOD_MASK) {
+	case ADV7181_STATUS1_AUTOD_NTSM_M_J:
+		return V4L2_STD_NTSC;
+	case ADV7181_STATUS1_AUTOD_NTSC_4_43:
+		return V4L2_STD_NTSC_443;
+	case ADV7181_STATUS1_AUTOD_PAL_M:
+		return V4L2_STD_PAL_M;
+	case ADV7181_STATUS1_AUTOD_PAL_60:
+		return V4L2_STD_PAL_60;
+	case ADV7181_STATUS1_AUTOD_PAL_B_G:
+		return V4L2_STD_PAL;
+	case ADV7181_STATUS1_AUTOD_SECAM:
+		return V4L2_STD_SECAM;
+	case ADV7181_STATUS1_AUTOD_PAL_COMB:
+		return V4L2_STD_PAL_Nc | V4L2_STD_PAL_N;
+	case ADV7181_STATUS1_AUTOD_SECAM_525:
+		return V4L2_STD_SECAM;
+	default:
+		return V4L2_STD_UNKNOWN;
+	}
+}
+
+static u32 adv7181_status_to_v4l2(u8 status1)
+{
+	if (!(status1 & ADV7181_STATUS1_IN_LOCK))
+		return V4L2_IN_ST_NO_SIGNAL;
+
+	return 0;
+}
+
+static int adv7181_vehicle_status(struct ad_dev *ad,
+				  u32 *status,
+				  v4l2_std_id *std)
+{
+	unsigned char status1 = 0;
+
+	status1 = vehicle_generic_sensor_read(ad, ADV7181_STATUS1_REG);
+	//DBG("ADV7181_STATUS1_REG: %x\n", status1);
+	if (status1 < 0)
+		return status1;
+
+	if (status)
+		*status = adv7181_status_to_v4l2(status1);
+
+	if (std)
+		*std = adv7181_std_to_v4l2(status1);
+
+	return 0;
+}
+
+static void adv7181_reinit_parameter(struct ad_dev *ad, v4l2_std_id std)
+{
+	int i;
+
+	ad->cfg.bus_param = ADV7181_SENSOR_BUS_PARAM;
+	if (std == V4L2_STD_PAL) {
+		ad->cfg.width = FORCE_PAL_WIDTH;
+		ad->cfg.height = FORCE_PAL_HEIGHT;
+		ad->cfg.start_x = 0;
+		ad->cfg.start_y = 0;
+		ad->cfg.input_format = CIF_INPUT_FORMAT_PAL;
+		ad->cfg.output_format = FORCE_CIF_OUTPUT_FORMAT;
+		ad->cfg.field_order = 0;
+		ad->cfg.yuv_order = 0;
+		ad->cfg.frame_rate = 25;
+	} else {
+		ad->cfg.width = FORCE_NTSC_WIDTH;
+		ad->cfg.height = FORCE_NTSC_HEIGHT;
+		ad->cfg.start_x = 0;
+		ad->cfg.start_y = 0;
+		ad->cfg.input_format = CIF_INPUT_FORMAT_NTSC;
+		ad->cfg.output_format = FORCE_CIF_OUTPUT_FORMAT;
+		ad->cfg.field_order = 0;
+		ad->cfg.yuv_order = 0;
+		ad->cfg.frame_rate = 30;
+	}
+
+	/*href:0,high;1,low*/
+	if (ad->cfg.bus_param | V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+		ad->cfg.href = 0;
+	else
+		ad->cfg.href = 1;
+	/*vsync:0,low;1,high*/
+	if (ad->cfg.bus_param | V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+		ad->cfg.vsync = 1;
+	else
+		ad->cfg.vsync = 0;
+
+	/* fix crop info from dts config */
+	for (i = 0; i < 4; i++) {
+		if ((ad->defrects[i].width == ad->cfg.width) &&
+		    (ad->defrects[i].height == ad->cfg.height)) {
+			ad->cfg.start_x = ad->defrects[i].crop_x;
+			ad->cfg.start_y = ad->defrects[i].crop_y;
+			ad->cfg.width = ad->defrects[i].crop_width;
+			ad->cfg.height = ad->defrects[i].crop_height;
+		}
+	}
+
+	DBG("size %dx%d, crop(%d,%d)\n",
+	    ad->cfg.width, ad->cfg.height,
+	    ad->cfg.start_x, ad->cfg.start_y);
+}
+
+static void adv7181_reg_init(struct ad_dev *ad, unsigned char cvstd)
+{
+	struct rk_sensor_reg *sensor;
+	int i = 0;
+	unsigned char val[2];
+
+	sensor = sensor_preview_data;
+
+	while ((sensor[i].reg != SEQCMD_END) && (sensor[i].reg != 0xFC000000)) {
+		val[0] = sensor[i].val;
+		vehicle_generic_sensor_write(ad, sensor[i].reg, val);
+		i++;
+	}
+}
+
+int adv7181_ad_get_cfg(struct vehicle_cfg **cfg)
+{
+	u32 status;
+
+	if (!g_addev)
+		return -1;
+
+	adv7181_vehicle_status(g_addev, &status, NULL);
+	if (status) /* No signal */
+		g_addev->cfg.ad_ready = false;
+	else
+		g_addev->cfg.ad_ready = true;
+
+	*cfg = &g_addev->cfg;
+
+	return 0;
+}
+
+void adv7181_ad_check_cif_error(struct ad_dev *ad, int last_line)
+{
+	DBG("%s, last_line %d\n", __func__, last_line);
+}
+
+int adv7181_check_id(struct ad_dev *ad)
+{
+	int ret = 0;
+	int val;
+
+	val = vehicle_generic_sensor_read(ad, 0x11);
+	DBG("%s read 0x11 --> 0x%02x\n", ad->ad_name, val);
+	if (val != 0x20) {
+		DBG("%s wrong camera ID, expected 0x20, detected 0x%02x\n",
+		    ad->ad_name, val);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int adv7181_check_std(struct ad_dev *ad, v4l2_std_id *std)
+{
+	u32 status;
+	static bool is_first = true;
+
+	adv7181_vehicle_status(ad, &status, std);
+
+	if (status && is_first) { /* No signal */
+		mdelay(30);
+		adv7181_vehicle_status(ad, &status, std);
+		//DBG("status 0x%x\n", status);
+	}
+
+	//if (status)
+		//*std = V4L2_STD_NTSC;
+
+	return 0;
+}
+
+static void power_on(struct ad_dev *ad)
+{
+	/* gpio_direction_output(ad->power, ad->pwr_active); */
+
+	if (gpio_is_valid(ad->powerdown)) {
+		gpio_request(ad->powerdown, "ad_powerdown");
+		gpio_direction_output(ad->powerdown, !ad->pwdn_active);
+		/* gpio_set_value(ad->powerdown, !ad->pwdn_active); */
+	}
+
+	if (gpio_is_valid(ad->power)) {
+		gpio_request(ad->power, "ad_power");
+		gpio_direction_output(ad->power, ad->pwr_active);
+		/* gpio_set_value(ad->power, ad->pwr_active); */
+	}
+}
+
+static void power_off(struct ad_dev *ad)
+{
+	if (gpio_is_valid(ad->powerdown))
+		gpio_free(ad->powerdown);
+
+	if (gpio_is_valid(ad->power))
+		gpio_free(ad->power);
+}
+
+static void adv7181_check_state_work(struct work_struct *work)
+{
+	struct ad_dev *ad;
+	v4l2_std_id std;
+
+	ad = g_addev;
+
+	if (ad->cif_error_last_line > 0)
+		ad->cif_error_last_line = 0;
+
+	adv7181_check_std(ad, &std);
+
+	if (std != std_old) {
+		std_old = std;
+		adv7181_reinit_parameter(ad, std);
+		vehicle_ad_stat_change_notify();
+	}
+
+	queue_delayed_work(ad->state_check_work.state_check_wq,
+			   &ad->state_check_work.work, msecs_to_jiffies(500));
+}
+
+int adv7181_ad_deinit(void)
+{
+	struct ad_dev *ad;
+
+	ad = g_addev;
+
+	if (!ad)
+		return -1;
+
+	if (ad->state_check_work.state_check_wq) {
+		cancel_delayed_work_sync(&ad->state_check_work.work);
+		flush_delayed_work(&ad->state_check_work.work);
+		flush_workqueue(ad->state_check_work.state_check_wq);
+		destroy_workqueue(ad->state_check_work.state_check_wq);
+	}
+	if (ad->irq)
+		free_irq(ad->irq, ad);
+	power_off(ad);
+	return 0;
+}
+
+int adv7181_ad_init(struct ad_dev *ad)
+{
+	int ret;
+	v4l2_std_id std;
+
+	if (!ad)
+		return -1;
+
+	g_addev = ad;
+
+	/*  1. i2c init */
+	ad->adapter = i2c_get_adapter(ad->i2c_chl);
+	if (ad->adapter == NULL)
+		return -1;
+
+	if (!i2c_check_functionality(ad->adapter, I2C_FUNC_I2C))
+		return -1;
+
+	/*  2. ad power on sequence */
+	power_on(ad);
+
+	/* fix mode */
+	adv7181_check_std(ad, &std);
+	std_old = std;
+	DBG("std: %s\n", (std == V4L2_STD_NTSC) ? "ntsc" : "pal");
+
+	/*  3 .init default format params */
+	adv7181_reg_init(ad, std);
+	adv7181_reinit_parameter(ad, std);
+	vehicle_ad_stat_change_notify();
+
+	/*  4. ad register signal detect irq */
+	if (0) {
+		ad->irq = gpio_to_irq(ad->cvstd);
+		ret = request_irq(ad->irq, NULL, IRQF_TRIGGER_FALLING,
+				  "vehicle ad_adv7181", ad);
+	}
+
+	/*  5. create workqueue to detect signal change */
+	INIT_DELAYED_WORK(&ad->state_check_work.work, adv7181_check_state_work);
+	ad->state_check_work.state_check_wq =
+		create_singlethread_workqueue("vehicle-ad-adv7181");
+
+	queue_delayed_work(ad->state_check_work.state_check_wq,
+			   &ad->state_check_work.work, msecs_to_jiffies(100));
+
+	return 0;
+}
+
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_ad_7181.h b/drivers/video/rockchip/vehicle/vehicle_ad_7181.h
new file mode 100644
index 0000000..305cc9a
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_ad_7181.h
@@ -0,0 +1,13 @@
+#ifndef __VEHICLE_AD_7181_H__
+#define __VEHICLE_AD_7181_H__
+
+extern struct ad_dev *g_addev;
+
+int adv7181_ad_init(struct ad_dev *ad);
+int adv7181_ad_deinit(void);
+int adv7181_ad_get_cfg(struct vehicle_cfg **cfg);
+void adv7181_ad_check_cif_error(struct ad_dev *ad, int last_line);
+int adv7181_check_id(struct ad_dev *ad);
+
+#endif
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_ad_tp2825.c b/drivers/video/rockchip/vehicle/vehicle_ad_tp2825.c
new file mode 100755
index 0000000..4d7656a
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_ad_tp2825.c
@@ -0,0 +1,1054 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/sysctl.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/uaccess.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include "vehicle_cfg.h"
+#include "vehicle_main.h"
+#include "vehicle_ad.h"
+#include "vehicle_ad_tp2825.h"
+
+/*PAL 50fps; NTSC 60fps*/
+/*#define CVBS_DOUBLE_FPS_MODE*/
+
+#define TP2825_SENSOR_BUS_PARAM	(V4L2_MBUS_MASTER | \
+	V4L2_MBUS_PCLK_SAMPLE_RISING | \
+	V4L2_MBUS_HSYNC_ACTIVE_HIGH | \
+	V4L2_MBUS_VSYNC_ACTIVE_HIGH | \
+	V4L2_MBUS_DATA_ACTIVE_HIGH | \
+	SOCAM_MCLK_24MHZ)
+
+
+enum {
+	CVSTD_720P60 = 0,
+	CVSTD_720P50,
+	CVSTD_1080P30,
+	CVSTD_1080P25,
+	CVSTD_720P30,
+	CVSTD_720P25,
+	CVSTD_SD,
+	CVSTD_NTSC,
+	CVSTD_PAL
+};
+
+enum {
+	FORCE_PAL_WIDTH = 960,
+	FORCE_PAL_HEIGHT = 576,
+	FORCE_NTSC_WIDTH = 960,
+	FORCE_NTSC_HEIGHT = 480,
+	FORCE_CIF_OUTPUT_FORMAT = CIF_OUTPUT_FORMAT_422,
+};
+
+enum {
+	VIDEO_UNPLUG,
+	VIDEO_IN,
+	VIDEO_LOCKED,
+	VIDEO_UNLOCK
+};
+#define FLAG_LOSS				(0x1 << 7)
+#define FLAG_V_LOCKED			(0x1 << 6)
+#define FLAG_H_LOCKED			(0x1 << 5)
+#define FLAG_CARRIER_PLL_LOCKED	(0x1 << 4)
+#define FLAG_VIDEO_DETECTED		(0x1 << 3)
+#define FLAG_EQ_SD_DETECTED		(0x1 << 2)
+#define FLAG_PROGRESSIVE		(0x1 << 1)
+#define FLAG_NO_CARRIER			(0x1 << 0)
+#define FLAG_LOCKED		(FLAG_V_LOCKED | FLAG_H_LOCKED)
+
+static int cvstd_mode = CVSTD_720P50;
+static int cvstd_old = CVSTD_720P50;
+static int cvstd_sd = CVSTD_NTSC;
+static int cvstd_state = VIDEO_UNPLUG;
+static int cvstd_old_state = VIDEO_UNPLUG;
+
+#define SENSOR_REGISTER_LEN	1	/* sensor register address bytes*/
+#define SENSOR_VALUE_LEN	1	/* sensor register value bytes*/
+
+struct rk_sensor_reg {
+	unsigned int reg;
+	unsigned int val;
+};
+
+#define SENSOR_CHANNEL_REG		0x41
+
+#define SEQCMD_END  0xFF000000
+#define SensorEnd   {SEQCMD_END, 0x00}
+
+#define SENSOR_DG DBG
+#define SENSOR_TR DBG
+
+/* Preview resolution setting*/
+static struct rk_sensor_reg sensor_preview_data_ntsc[] = {
+	{0x02, 0xCF},
+	{0x06, 0x32},
+	{0x07, 0xC0},
+	{0x08, 0x00},
+	{0x09, 0x24},
+	{0x0A, 0x48},
+	{0x0B, 0xC0},
+	{0x0C, 0x53},
+	{0x0D, 0x10},
+	{0x0E, 0x00},
+	{0x0F, 0x00},
+	{0x10, 0x5e},
+	{0x11, 0x40},
+	{0x12, 0x44},
+	{0x13, 0x00},
+	{0x14, 0x00},
+	{0x15, 0x13},
+	{0x16, 0x4E},
+	{0x17, 0xBC},
+	{0x18, 0x15},
+	{0x19, 0xF0},
+	{0x1A, 0x07},
+	{0x1B, 0x00},
+	{0x1C, 0x09},
+	{0x1D, 0x38},
+	{0x1E, 0x80},
+	{0x1F, 0x80},
+	{0x20, 0xA0},
+	{0x21, 0x86},
+	{0x22, 0x38},
+	{0x23, 0x3C},
+	{0x24, 0x56},
+	{0x25, 0xFF},
+	{0x26, 0x12},
+	{0x27, 0x2D},
+	{0x28, 0x00},
+	{0x29, 0x48},
+	{0x2A, 0x30},
+	{0x2B, 0x70},
+	{0x2C, 0x1A},
+	{0x2D, 0x68},
+	{0x2E, 0x5E},
+	{0x2F, 0x00},
+	{0x30, 0x62},
+	{0x31, 0xBB},
+	{0x32, 0x96},
+	{0x33, 0xC0},
+	{0x34, 0x00},
+	{0x35, 0x65},
+	{0x36, 0xDC},
+	{0x37, 0x00},
+	{0x38, 0x40},
+	{0x39, 0x84},
+	{0x3A, 0x00},
+	{0x3B, 0x03},
+	{0x3C, 0x00},
+	{0x3D, 0x60},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x00},
+	{0x42, 0x00},
+	{0x43, 0x12},
+	{0x44, 0x07},
+	{0x45, 0x49},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0x03},
+	{0x4D, 0x03},
+	{0x4E, 0x37},
+	{0x4F, 0x01},
+	{0xB5, 0x01},
+	{0xB8, 0x00},
+	{0xBA, 0x00},
+	{0xF3, 0x00},
+	{0xF4, 0x00},
+	{0xF5, 0x00},
+	{0xF6, 0x00},
+	{0xF7, 0x00},
+	{0xF8, 0x00},
+	{0xF9, 0x00},
+	{0xFA, 0x00},
+	{0xFB, 0x00},
+	{0xFC, 0xC0},
+	{0xFD, 0x00},
+	SensorEnd
+};
+
+static struct rk_sensor_reg sensor_preview_data_pal[] = {
+	{0x02, 0xDE},
+	{0x06, 0x32},
+	{0x07, 0xC0},
+	{0x08, 0x00},
+	{0x09, 0x24},
+	{0x0A, 0x48},
+	{0x0B, 0xC0},
+	{0x0C, 0x53},
+	{0x0D, 0x11},
+	{0x0E, 0x00},
+	{0x0F, 0x00},
+	{0x10, 0x70},
+	{0x11, 0x4D},
+	{0x12, 0x40},
+	{0x13, 0x00},
+	{0x14, 0x00},
+	{0x15, 0x13},
+	{0x16, 0x67},
+	{0x17, 0xBC},
+	{0x18, 0x16},
+	{0x19, 0x20},
+	{0x1A, 0x17},
+	{0x1B, 0x00},
+	{0x1C, 0x09},
+	{0x1D, 0x48},
+	{0x1E, 0x80},
+	{0x1F, 0x80},
+	{0x20, 0xB0},
+	{0x21, 0x86},
+	{0x22, 0x38},
+	{0x23, 0x3C},
+	{0x24, 0x56},
+	{0x25, 0xFF},
+	{0x26, 0x02},
+	{0x27, 0x2D},
+	{0x28, 0x00},
+	{0x29, 0x48},
+	{0x2A, 0x30},
+	{0x2B, 0x70},
+	{0x2C, 0x1A},
+	{0x2D, 0x60},
+	{0x2E, 0x5E},
+	{0x2F, 0x00},
+	{0x30, 0x7A},
+	{0x31, 0x4A},
+	{0x32, 0x4D},
+	{0x33, 0xF0},
+	{0x34, 0x00},
+	{0x35, 0x65},
+	{0x36, 0xDC},
+	{0x37, 0x00},
+	{0x38, 0x40},
+	{0x39, 0x84},
+	{0x3A, 0x00},
+	{0x3B, 0x03},
+	{0x3C, 0x00},
+	{0x3D, 0x60},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x00},
+	{0x42, 0x00},
+	{0x43, 0x12},
+	{0x44, 0x07},
+	{0x45, 0x49},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0xC3},/*C0*/
+	{0x4D, 0x01},
+	{0x4E, 0x37},
+	{0x4F, 0x00},
+	{0xB5, 0x01},
+	{0xB8, 0x00},
+	{0xBA, 0x00},
+	{0xF3, 0x00},
+	{0xF4, 0x00},
+	{0xF5, 0x00},
+	{0xF6, 0x00},
+	{0xF7, 0x00},
+	{0xF8, 0x00},
+	{0xF9, 0x00},
+	{0xFA, 0x00},
+	{0xFB, 0x00},
+	{0xFC, 0xC0},
+	{0xFD, 0x00},
+	SensorEnd
+};
+
+static struct rk_sensor_reg sensor_preview_data_720p_50hz[] = {
+	{0x02, 0xCA},
+	{0x06, 0x32},
+	{0x07, 0xC0},
+	{0x08, 0x00},
+	{0x09, 0x24},
+	{0x0A, 0x48},
+	{0x0B, 0xC0},
+	{0x0C, 0x43},
+	{0x0D, 0x10},
+	{0x0E, 0x00},
+	{0x0F, 0x00},
+	{0x10, 0xf0},
+	{0x11, 0x50},
+	{0x12, 0x60},
+	{0x13, 0x00},
+	{0x14, 0x08},
+	{0x15, 0x13},
+	{0x16, 0x16},
+	{0x17, 0x00},
+	{0x18, 0x18},
+	{0x19, 0xD0},
+	{0x1A, 0x25},
+	{0x1B, 0x00},
+	{0x1C, 0x07},
+	{0x1D, 0xBC},
+	{0x1E, 0x80},
+	{0x1F, 0x80},
+	{0x20, 0x60},
+	{0x21, 0x86},
+	{0x22, 0x38},
+	{0x23, 0x3C},
+	{0x24, 0x56},
+	{0x25, 0xFF},
+	{0x26, 0x02},
+	{0x27, 0x2D},
+	{0x28, 0x00},
+	{0x29, 0x48},
+	{0x2A, 0x30},
+	{0x2B, 0x4A},
+	{0x2C, 0x1A},
+	{0x2D, 0x30},
+	{0x2E, 0x70},
+	{0x2F, 0x00},
+	{0x30, 0x48},
+	{0x31, 0xBB},
+	{0x32, 0x2E},
+	{0x33, 0x90},
+	{0x34, 0x00},
+	{0x35, 0x05},
+	{0x36, 0xDC},
+	{0x37, 0x00},
+	{0x38, 0x40},
+	{0x39, 0x8C},
+	{0x3A, 0x00},
+	{0x3B, 0x03},
+	{0x3C, 0x00},
+	{0x3D, 0x60},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x00},
+	{0x42, 0x00},
+	{0x43, 0x12},
+	{0x44, 0x07},
+	{0x45, 0x49},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0x03},
+	{0x4D, 0x03},
+	{0x4E, 0x03},
+	{0x4F, 0x01},
+	{0xB5, 0x01},
+	{0xB8, 0x00},
+	{0xBA, 0x00},
+	{0xF3, 0x00},
+	{0xF4, 0x00},
+	{0xF5, 0x00},
+	{0xF6, 0x00},
+	{0xF7, 0x00},
+	{0xF8, 0x00},
+	{0xF9, 0x00},
+	{0xFA, 0x00},
+	{0xFB, 0x00},
+	{0xFC, 0xC0},
+	{0xFD, 0x00},
+	SensorEnd
+};
+static struct rk_sensor_reg sensor_preview_data_720p_30hz[] = {
+	{0x02, 0xDA},
+	{0x06, 0x32},
+	{0x07, 0xC0},
+	{0x08, 0x00},
+	{0x09, 0x24},
+	{0x0A, 0x48},
+	{0x0B, 0xC0},
+	{0x0C, 0x53},
+	{0x0D, 0x10},
+	{0x0E, 0x00},
+	{0x0F, 0x00},
+	{0x10, 0xf0},
+	{0x11, 0x50},
+	{0x12, 0x60},
+	{0x13, 0x00},
+	{0x14, 0x08},
+	{0x15, 0x13},
+	{0x16, 0x16},
+	{0x17, 0x00},
+	{0x18, 0x19},
+	{0x19, 0xD0},
+	{0x1A, 0x25},
+	{0x1B, 0x00},
+	{0x1C, 0x06},
+	{0x1D, 0x72},
+	{0x1E, 0x80},
+	{0x1F, 0x80},
+	{0x20, 0x60},
+	{0x21, 0x86},
+	{0x22, 0x38},
+	{0x23, 0x3C},
+	{0x24, 0x56},
+	{0x25, 0xFF},
+	{0x26, 0x02},
+	{0x27, 0x2D},
+	{0x28, 0x00},
+	{0x29, 0x48},
+	{0x2A, 0x30},
+	{0x2B, 0x4A},
+	{0x2C, 0x1A},
+	{0x2D, 0x30},
+	{0x2E, 0x70},
+	{0x2F, 0x00},
+	{0x30, 0x48},
+	{0x31, 0xBB},
+	{0x32, 0x2E},
+	{0x33, 0x90},
+	{0x34, 0x00},
+	{0x35, 0x25},
+	{0x36, 0xDC},
+	{0x37, 0x00},
+	{0x38, 0x40},
+	{0x39, 0x88},
+	{0x3A, 0x00},
+	{0x3B, 0x03},
+	{0x3C, 0x00},
+	{0x3D, 0x60},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x03},
+	{0x41, 0x00},
+	{0x42, 0x00},
+	{0x43, 0x12},
+	{0x44, 0x07},
+	{0x45, 0x49},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0x03},
+	{0x4D, 0x03},
+	{0x4E, 0x17},
+	{0x4F, 0x01},
+	{0x85, 0x00},
+	{0x88, 0x00},
+	{0x8A, 0x00},
+	{0xF3, 0x00},
+	{0xF4, 0x00},
+	{0xF5, 0x00},
+	{0xF6, 0x00},
+	{0xF7, 0x00},
+	{0xF8, 0x00},
+	{0xF9, 0x00},
+	{0xFA, 0x00},
+	{0xFB, 0x00},
+	{0xFC, 0xC0},
+	{0xFD, 0x00},
+	SensorEnd
+};
+static struct rk_sensor_reg sensor_preview_data_720p_25hz[] = {
+	{0x02, 0xCA},
+	{0x06, 0x32},
+	{0x07, 0xC0},
+	{0x08, 0x00},
+	{0x09, 0x24},
+	{0x0A, 0x48},
+	{0x0B, 0xC0},
+	{0x0C, 0x53},
+	{0x0D, 0x10},
+	{0x0E, 0x00},
+	{0x0F, 0x00},
+	{0x10, 0xf0},
+	{0x11, 0x50},
+	{0x12, 0x60},
+	{0x13, 0x00},
+	{0x14, 0x08},
+	{0x15, 0x13},
+	{0x16, 0x16},
+	{0x17, 0x00},
+	{0x18, 0x19},
+	{0x19, 0xD0},
+	{0x1A, 0x25},
+	{0x1B, 0x00},
+	{0x1C, 0x07},
+	{0x1D, 0xBC},
+	{0x1E, 0x80},
+	{0x1F, 0x80},
+	{0x20, 0x60},
+	{0x21, 0x86},
+	{0x22, 0x38},
+	{0x23, 0x3C},
+	{0x24, 0x56},
+	{0x25, 0xFF},
+	{0x26, 0x02},
+	{0x27, 0x2D},
+	{0x28, 0x00},
+	{0x29, 0x48},
+	{0x2A, 0x30},
+	{0x2B, 0x70},
+	{0x2C, 0x1A},
+	{0x2D, 0x30},
+	{0x2E, 0x70},
+	{0x2F, 0x00},
+	{0x30, 0x48},
+	{0x31, 0xBB},
+	{0x32, 0x2E},
+	{0x33, 0x90},
+	{0x34, 0x00},
+	{0x35, 0x25},
+	{0x36, 0xDC},
+	{0x37, 0x00},
+	{0x38, 0x40},
+	{0x39, 0x88},
+	{0x3A, 0x00},
+	{0x3B, 0x03},
+	{0x3C, 0x00},
+	{0x3D, 0x60},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x00},
+	{0x42, 0x00},
+	{0x43, 0x12},
+	{0x44, 0x07},
+	{0x45, 0x49},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0x03},
+	{0x4D, 0x03},
+	{0x4E, 0x17},
+	{0x4F, 0x01},
+	{0xB5, 0x01},
+	{0xB8, 0x00},
+	{0xBA, 0x00},
+	{0xF3, 0x00},
+	{0xF4, 0x00},
+	{0xF5, 0x00},
+	{0xF6, 0x00},
+	{0xF7, 0x00},
+	{0xF8, 0x00},
+	{0xF9, 0x00},
+	{0xFA, 0x00},
+	{0xFB, 0x00},
+	{0xFC, 0xC0},
+	{0xFD, 0x00},
+	SensorEnd
+};
+
+static void tp2825_reinit_parameter(struct ad_dev *ad, unsigned char cvstd)
+{
+	int i, defrect_index = -1;
+
+	ad->cfg.bus_param = TP2825_SENSOR_BUS_PARAM;
+	switch (cvstd) {
+	case CVSTD_PAL:
+		ad->cfg.width = FORCE_PAL_WIDTH;
+		ad->cfg.height = FORCE_PAL_HEIGHT;
+		ad->cfg.start_x = 0;
+		ad->cfg.start_y = 0;
+		ad->cfg.input_format = CIF_INPUT_FORMAT_PAL;
+		ad->cfg.output_format = FORCE_CIF_OUTPUT_FORMAT;
+		ad->cfg.field_order = 0;
+		ad->cfg.yuv_order = 0;
+		ad->cfg.href = 0;
+		ad->cfg.vsync = 0;
+		ad->cfg.frame_rate = 25;
+		break;
+	case CVSTD_NTSC:
+		ad->cfg.width = FORCE_NTSC_WIDTH;
+		ad->cfg.height = FORCE_NTSC_HEIGHT;
+		ad->cfg.start_x = 0;
+		ad->cfg.start_y = 0;
+		ad->cfg.input_format = CIF_INPUT_FORMAT_NTSC;
+		ad->cfg.output_format = FORCE_CIF_OUTPUT_FORMAT;
+		ad->cfg.field_order = 0;
+		ad->cfg.yuv_order = 0;
+		ad->cfg.href = 0;
+		ad->cfg.vsync = 0;
+		ad->cfg.frame_rate = 30;
+		break;
+	default:
+		ad->cfg.width = 1280;
+		ad->cfg.height = 720;
+		ad->cfg.start_x = 8;
+		ad->cfg.start_y = 20;
+		ad->cfg.input_format = CIF_INPUT_FORMAT_YUV;
+		ad->cfg.output_format = FORCE_CIF_OUTPUT_FORMAT;
+		ad->cfg.field_order = 0;
+		ad->cfg.yuv_order = 0;/*00 - UYVY*/
+		/*href:0,high;1,low*/
+        if (ad->cfg.bus_param | V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+            ad->cfg.href = 0;
+        else
+            ad->cfg.href = 1;
+		/*vsync:0,low;1,high*/
+		if (ad->cfg.bus_param | V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+			ad->cfg.vsync = 1;
+		else
+			ad->cfg.vsync = 0;
+		ad->cfg.frame_rate = 50;
+		break;
+	}
+
+	/* fix crop info from dts config */
+	for (i = 0; i < 4; i++) {
+		if ((ad->defrects[i].width == ad->cfg.width) &&
+		    (ad->defrects[i].height == ad->cfg.height)) {
+			ad->cfg.start_x = ad->defrects[i].crop_x;
+			ad->cfg.start_y = ad->defrects[i].crop_y;
+			ad->cfg.width = ad->defrects[i].crop_width;
+			ad->cfg.height = ad->defrects[i].crop_height;
+			defrect_index = i;
+		}
+	}
+
+#ifdef CVBS_DOUBLE_FPS_MODE
+	if (defrect_index != -1) {
+		switch (cvstd) {
+		case CVSTD_PAL:
+			if (strstr(ad->defrects[defrect_index].interface, "pal")) {
+				ad->cfg.height /= 2;
+				ad->cfg.input_format =
+					CIF_INPUT_FORMAT_PAL_SW_COMPOSITE;
+				ad->cfg.href = 0;
+				ad->cfg.vsync = 1;
+				ad->cfg.frame_rate = 50;
+			}
+		break;
+		case CVSTD_NTSC:
+			if (strstr(ad->defrects[defrect_index].interface, "ntsc")) {
+				ad->cfg.height /= 2;
+				ad->cfg.input_format =
+					CIF_INPUT_FORMAT_NTSC_SW_COMPOSITE;
+				ad->cfg.href = 0;
+				ad->cfg.vsync = 1;
+				ad->cfg.frame_rate = 60;
+			}
+		break;
+		}
+	}
+#endif
+	DBG("%s,interface %d = %s, crop(%d,%d)",
+		__func__,
+		defrect_index,
+		ad->defrects[defrect_index].interface,
+		ad->cfg.start_x,
+		ad->cfg.start_y);
+}
+
+static void tp2825_reg_init(struct ad_dev *ad, unsigned char cvstd)
+{
+	struct rk_sensor_reg *sensor;
+	int i;
+	unsigned char val[2];
+
+	switch (cvstd) {
+	case CVSTD_720P50:
+		sensor = sensor_preview_data_720p_50hz;
+		break;
+	case CVSTD_720P30:
+		sensor = sensor_preview_data_720p_30hz;
+		break;
+	case CVSTD_720P25:
+		sensor = sensor_preview_data_720p_25hz;
+		break;
+	case CVSTD_PAL:
+		sensor = sensor_preview_data_pal;
+		break;
+	case CVSTD_NTSC:
+		sensor = sensor_preview_data_ntsc;
+		break;
+	default:
+		sensor = sensor_preview_data_720p_50hz;
+		break;
+	}
+	i = 0;
+	while ((sensor[i].reg != SEQCMD_END) && (sensor[i].reg != 0xFC000000)) {
+		/*if (sensor[i].reg == 0x4F)
+		  sensor[i].val = 0x01;
+		  if (sensor[i].reg == 0xB8)
+		  sensor[i].val = 0x03;
+		  if (sensor[i].reg == 0xBA)
+		  sensor[i].val = 0x10; */
+		if (SENSOR_CHANNEL_REG == sensor[i].reg)
+			sensor[i].val = ad->ad_chl;
+
+		val[0] = sensor[i].val;
+		vehicle_generic_sensor_write(ad, sensor[i].reg, val);
+		i++;
+	}
+}
+
+int tp2825_ad_get_cfg(struct vehicle_cfg **cfg)
+{
+	if (!g_addev)
+		return -1;
+
+	switch (cvstd_state) {
+	case VIDEO_UNPLUG:
+		g_addev->cfg.ad_ready = false;
+		break;
+	case VIDEO_LOCKED:
+		g_addev->cfg.ad_ready = true;
+		break;
+	case VIDEO_IN:
+		g_addev->cfg.ad_ready = false;
+		break;
+	}
+
+	*cfg = &g_addev->cfg;
+
+	return 0;
+}
+
+void tp2825_ad_check_cif_error(struct ad_dev *ad, int last_line)
+{
+	DBG("%s, last_line %d\n", __func__, last_line);
+	if (last_line < 1)
+		return;
+
+	ad->cif_error_last_line = last_line;
+	if (CVSTD_PAL == cvstd_mode) {
+		if (last_line == FORCE_NTSC_HEIGHT) {
+			if (ad->state_check_work.state_check_wq)
+				queue_delayed_work(
+						   ad->state_check_work.
+						   state_check_wq,
+						   &ad->state_check_work.work,
+						   msecs_to_jiffies(0));
+		}
+	} else if (CVSTD_NTSC == cvstd_mode) {
+		if (last_line == FORCE_PAL_HEIGHT) {
+			if (ad->state_check_work.state_check_wq)
+				queue_delayed_work(
+						   ad->state_check_work.
+						   state_check_wq,
+						   &ad->state_check_work.work,
+						   msecs_to_jiffies(0));
+		}
+	}
+}
+
+int tp2825_check_id(struct ad_dev *ad)
+{
+	int ret = 0;
+	int pidh, pidl;
+
+	pidh = vehicle_generic_sensor_read(ad, 0xfe);
+	pidl = vehicle_generic_sensor_read(ad, 0xff);
+	DBG("%s read 0xfe 0xff --> 0x%02x 0x%02x\n", ad->ad_name, pidh, pidl);
+	if (pidh != 0x28 || pidl != 0x25) {
+		DBG("%s: expected 0x2825, detected 0x%02x 0x%02x\n",
+		    ad->ad_name, pidh, pidl);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int tp2825_check_cvstd(struct ad_dev *ad, bool activate_check)
+{
+	unsigned char cvstd;
+	unsigned char status;
+	static bool is_first = true;
+	static int state = VIDEO_UNPLUG;
+	int check_count = 20;
+	unsigned char v[2];
+
+check_continue:
+	status = vehicle_generic_sensor_read(ad, 0x01);
+
+	if (status & FLAG_LOSS) {
+		state = VIDEO_UNPLUG;
+		v[0] = 0x01;
+		vehicle_generic_sensor_write(ad, 0x26, v);
+	} else if (FLAG_LOCKED == (status & FLAG_LOCKED)) {
+		/* video locked */
+		state = VIDEO_LOCKED;
+		v[0] = 0x02;
+		vehicle_generic_sensor_write(ad, 0x26, v);
+	} else {
+		/* video in but unlocked */
+		state = VIDEO_IN;
+		v[0] = 0x02;
+		vehicle_generic_sensor_write(ad, 0x26, v);
+	}
+
+	if (state == VIDEO_IN) {
+		cvstd = vehicle_generic_sensor_read(ad, 0x03);
+		SENSOR_TR("%s(%d): cvstd_old %d, read 0x03 return 0x%x",
+			  __func__, __LINE__, cvstd_old, cvstd);
+
+		cvstd &= 0x07;
+		if (cvstd == cvstd_old)
+			goto check_end;
+
+		if (cvstd == CVSTD_720P30) {
+			cvstd_mode = CVSTD_720P30;
+			SENSOR_TR("%s(%d): 720P30\n", __func__, __LINE__);
+		} else if (cvstd == CVSTD_720P25) {
+			cvstd_mode = CVSTD_720P25;
+			SENSOR_TR("%s(%d): 720P25\n", __func__, __LINE__);
+		} else if (cvstd == CVSTD_720P60) {
+			SENSOR_TR("%s(%d): 720P60", __func__, __LINE__);
+		} else if (cvstd == CVSTD_720P50) {
+			cvstd_mode = CVSTD_720P50;
+			SENSOR_TR("%s(%d): 720P50\n", __func__, __LINE__);
+		} else if (cvstd == CVSTD_1080P30) {
+			SENSOR_TR("%s(%d): 1080P30", __func__, __LINE__);
+		} else if (cvstd == CVSTD_1080P25) {
+			SENSOR_TR("%s(%d): 1080P25", __func__, __LINE__);
+		} else if (cvstd == CVSTD_SD) {
+			if (!activate_check || is_first)
+				cvstd_sd = (CVSTD_NTSC == cvstd_sd) ?
+						 CVSTD_PAL : CVSTD_NTSC;
+			SENSOR_TR("%s(%d): cvstd_sd is %s\n",
+				  __func__, __LINE__,
+				  (cvstd_sd == CVSTD_PAL) ? "PAL" : "NTSC");
+			cvstd_mode = cvstd_sd;
+		}
+		tp2825_reinit_parameter(ad, cvstd_mode);
+	} else if (state == VIDEO_LOCKED) {
+		goto check_end;
+	} else {
+		SENSOR_TR("tp2825_check_cvstd: check sensor statue failed!\n");
+		goto check_end;
+	}
+
+	tp2825_reg_init(ad, cvstd_mode);
+check_end:
+	if (check_count && is_first && (state != VIDEO_LOCKED)) {
+		check_count--;
+		if (cvstd == CVSTD_SD)
+			mdelay(500);
+		else
+			mdelay(100);
+		goto check_continue;
+	}
+	is_first = false;
+	cvstd_state = state;
+	return 0;
+
+	/* check_failed: */
+	is_first = false;
+	cvstd_state = state;
+	return -1;
+}
+
+static void power_on(struct ad_dev *ad)
+{
+	/* gpio_direction_output(ad->power, ad->pwr_active); */
+
+	if (gpio_is_valid(ad->powerdown)) {
+		gpio_request(ad->powerdown, "ad_powerdown");
+		gpio_direction_output(ad->powerdown, !ad->pwdn_active);
+		/* gpio_set_value(ad->powerdown, !ad->pwdn_active); */
+	}
+
+	if (gpio_is_valid(ad->power)) {
+		gpio_request(ad->power, "ad_power");
+		gpio_direction_output(ad->power, ad->pwr_active);
+		/* gpio_set_value(ad->power, ad->pwr_active); */
+	}
+}
+
+static void power_off(struct ad_dev *ad)
+{
+	if (gpio_is_valid(ad->power))
+		gpio_free(ad->power);
+	if (gpio_is_valid(ad->powerdown))
+		gpio_free(ad->powerdown);
+}
+
+/* tp2825 irq interrupt process */
+static irqreturn_t tp2825_irq(int irq, void *dev_id)
+{
+	struct ad_dev *ad = (struct ad_dev *)dev_id;
+	unsigned char val;
+	unsigned char v[2];
+
+	val = vehicle_generic_sensor_read(ad, 0xB5);
+
+	DBG("%s(%d): read 0xB5 val 0x%x\n", __func__, __LINE__, val);
+
+	if (tp2825_check_cvstd(ad, false) < 0) {
+		ad->cfg.width = 0;
+		ad->cfg.height = 0;
+		ad->cfg.ad_ready = false;
+	}
+	/* notify vehicle main */
+	vehicle_ad_stat_change_notify();
+
+	v[0] = 0x1;
+	vehicle_generic_sensor_write(ad, 0xB5, v);
+
+	DBG("%s(%d): write 0xB5 val 0x01\n", __func__, __LINE__);
+	return IRQ_HANDLED;
+}
+
+static void tp2825_check_state_work(struct work_struct *work)
+{
+	struct ad_dev *ad;
+
+	ad = g_addev;
+
+	if (ad->cif_error_last_line > 0) {
+		tp2825_check_cvstd(ad, true);
+		ad->cif_error_last_line = 0;
+	} else {
+		tp2825_check_cvstd(ad, false);
+	}
+
+	if (cvstd_old != cvstd_mode || cvstd_old_state != cvstd_state) {
+		cvstd_old = cvstd_mode;
+		cvstd_old_state = cvstd_state;
+		vehicle_ad_stat_change_notify();
+	}
+
+	queue_delayed_work(ad->state_check_work.state_check_wq,
+			   &ad->state_check_work.work, msecs_to_jiffies(3000));
+}
+
+int tp2825_ad_deinit(void)
+{
+	struct ad_dev *ad;
+
+	ad = g_addev;
+
+	if (!ad)
+		return -1;
+
+	if (ad->state_check_work.state_check_wq) {
+		cancel_delayed_work_sync(&ad->state_check_work.work);
+		flush_delayed_work(&ad->state_check_work.work);
+		flush_workqueue(ad->state_check_work.state_check_wq);
+		destroy_workqueue(ad->state_check_work.state_check_wq);
+	}
+	if (ad->irq)
+		free_irq(ad->irq, ad);
+	power_off(ad);
+	return 0;
+}
+
+static int get_ad_mode_from_fix_format(int fix_format)
+{
+	int mode = -1;
+
+	switch (fix_format) {
+	case AD_FIX_FORMAT_PAL:
+		mode = CVSTD_PAL;
+		break;
+	case AD_FIX_FORMAT_NTSC:
+		mode = CVSTD_NTSC;
+		break;
+	case AD_FIX_FORMAT_720P_50FPS:
+		mode = CVSTD_720P50;
+		break;
+	case AD_FIX_FORMAT_720P_30FPS:
+		mode = CVSTD_720P30;
+		break;
+	case AD_FIX_FORMAT_720P_25FPS:
+		mode = CVSTD_720P25;
+		break;
+	default:
+		mode = -1;
+		break;
+	}
+	return mode;
+}
+
+int tp2825_ad_init(struct ad_dev *ad)
+{
+	int val;
+	int ret;
+	int i = 0;
+	int mode;
+
+	g_addev = ad;
+
+	/*  1. i2c init */
+	ad->adapter = i2c_get_adapter(ad->i2c_chl);
+	if (ad->adapter == NULL)
+		return -1;
+
+	if (!i2c_check_functionality(ad->adapter, I2C_FUNC_I2C))
+		return -1;
+
+	DBG("%s\n", __func__);
+
+	/*  2. ad power on sequence */
+	power_on(ad);
+
+	while (++i < 5) {
+		msleep(1);
+		val = vehicle_generic_sensor_read(ad, 0x12);
+		if (val != 0xff)
+			break;
+		DBG("tp2825_init i2c_reg_read fail\n");
+	}
+
+	/* fix mode */
+	mode = get_ad_mode_from_fix_format(ad->fix_format);
+	if (mode > 0) {
+		DBG("fix format %d, fix cvxtd mode %d\n", ad->fix_format, mode);
+		tp2825_reg_init(ad, mode);
+		tp2825_reinit_parameter(ad, mode);
+		DBG("%s after init\n", __func__);
+		/* wait for signal locked; */
+		i = 0;
+		while (++i < 10) {
+			msleep(100);
+			val = vehicle_generic_sensor_read(ad, 0x01);
+			if ((FLAG_LOCKED == (val & FLAG_LOCKED)))
+				break;
+		}
+		cvstd_state = VIDEO_LOCKED;
+		DBG("%s after video locked, val = 0x%x\n", __func__, val);
+		return 0;
+	}
+
+	/*  3 .init default format params */
+	tp2825_reg_init(ad, cvstd_mode);
+	tp2825_reinit_parameter(ad, cvstd_mode);
+	DBG("%s after reinit init\n", __func__);
+
+	/*  4. ad register signal detect irq */
+	if (0) {
+		ad->irq = gpio_to_irq(ad->cvstd);
+		ret = request_irq(ad->irq, tp2825_irq, IRQF_TRIGGER_FALLING,
+				  "vehicle ad_tp2825", ad);
+		tp2825_check_cvstd(ad, true);
+	}
+
+	/*  5. create workqueue to detect signal change */
+	INIT_DELAYED_WORK(&ad->state_check_work.work, tp2825_check_state_work);
+	ad->state_check_work.state_check_wq =
+		create_singlethread_workqueue("vehicle-ad-tp2825");
+
+	/* tp2825_check_cvstd(ad, true); */
+
+	queue_delayed_work(ad->state_check_work.state_check_wq,
+			   &ad->state_check_work.work, msecs_to_jiffies(100));
+
+	return 0;
+}
+
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_ad_tp2825.h b/drivers/video/rockchip/vehicle/vehicle_ad_tp2825.h
new file mode 100644
index 0000000..d2a3f86
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_ad_tp2825.h
@@ -0,0 +1,13 @@
+#ifndef __VEHICLE_AD_TP2825_H__
+#define __VEHICLE_AD_TP2825_H__
+
+extern struct ad_dev *g_addev;
+
+int tp2825_ad_init(struct ad_dev *ad);
+int tp2825_ad_deinit(void);
+int tp2825_ad_get_cfg(struct vehicle_cfg **cfg);
+void tp2825_ad_check_cif_error(struct ad_dev *ad, int last_line);
+int tp2825_check_id(struct ad_dev *ad);
+
+#endif
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_cfg.h b/drivers/video/rockchip/vehicle/vehicle_cfg.h
new file mode 100755
index 0000000..a2dee1b
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_cfg.h
@@ -0,0 +1,99 @@
+#ifndef __VEHICLE_CFG
+#define __VEHICLE_CFG
+#include "media/soc_camera.h"
+/* Driver information */
+#define VEHICLE_DRIVER_NAME		"Vehicle"
+
+#define VEHICLE_VERSION   "1.000"
+
+#define VEHICLE_DEBUG 1
+
+#if VEHICLE_DEBUG
+#define DBG(format, args...) \
+	pr_info("%s %s(%d): " format, VEHICLE_DRIVER_NAME, \
+		__func__, __LINE__, ## args)
+#else
+#define DBG(format, args...)
+#endif
+
+#define MAX_BUF_NUM (6)
+
+#define CVBS_DOUBLE_FPS_MODE	/*PAL 50fps; NTSC 60fps*/
+
+enum {
+	CIF_INPUT_FORMAT_YUV = 0,
+	CIF_INPUT_FORMAT_PAL = 2,
+	CIF_INPUT_FORMAT_NTSC = 3,
+	CIF_INPUT_FORMAT_RAW = 4,
+	CIF_INPUT_FORMAT_JPEG = 5,
+	CIF_INPUT_FORMAT_MIPI = 6,
+	CIF_INPUT_FORMAT_PAL_SW_COMPOSITE = 0xff000000,
+	CIF_INPUT_FORMAT_NTSC_SW_COMPOSITE = 0xfe000000,
+};
+
+enum {
+	CIF_OUTPUT_FORMAT_422 = 0,
+	CIF_OUTPUT_FORMAT_420 = 1,
+};
+
+struct vehicle_cfg {
+	int width;
+	int height;
+	/*
+action:	source video data input format.
+000 - YUV
+010 - PAL
+011 - NTSC
+100 - RAW
+101 - JPEG
+110 - MIPI
+*/
+	int input_format;
+	/*
+	   0 - output is 422
+	   1 - output is 420
+	   */
+	int output_format;
+	/*
+	   YUV input order
+	   00 - UYVY
+	   01 - YVYU
+	   10 - VYUY
+	   11 - YUYV
+	   */
+	int yuv_order;
+	/*
+	   ccir input order
+0 : odd field first
+1 : even field first
+*/
+	int field_order;
+	/*
+	   BT.656 not use
+	   BT.601 hsync polarity
+val:
+0-low active
+1-high active
+*/
+	int href;
+	/*
+	   BT.656 not use
+	   BT.601 hsync polarity
+val :
+0-low active
+1-high active
+*/
+	int vsync;
+	int start_x;
+	int start_y;
+	int frame_rate;
+
+	unsigned int buf_phy_addr[MAX_BUF_NUM];
+	unsigned int buf_num;
+	bool ad_ready;
+	/*0:no, 1:90; 2:180; 4:270; 0x10:mirror-y; 0x20:mirror-x*/
+	int rotate_mirror;
+	unsigned int bus_param;
+};
+
+#endif
diff --git a/drivers/video/rockchip/vehicle/vehicle_cif.c b/drivers/video/rockchip/vehicle/vehicle_cif.c
new file mode 100755
index 0000000..7ad108e
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_cif.c
@@ -0,0 +1,786 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/rockchip/cru.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#include "vehicle_cif.h"
+#include "vehicle_flinger.h"
+#include "vehicle_main.h"
+
+#define __raw_readl(p)	  (*(unsigned int *)(p))
+#define __raw_writel(v, p)     (*(unsigned int *)(p) = (v))
+
+#define write_cif_reg(base, addr, val)  __raw_writel(val, addr+(base))
+#define read_cif_reg(base, addr) __raw_readl(addr+(base))
+struct vehicle_cif *g_cif = NULL;
+
+#define CRU_BASE (g_cif->cru_base)
+
+#define write_cru_reg(addr, val)	__raw_writel(val, addr+CRU_BASE)
+#define read_cru_reg(addr)	__raw_readl(addr+CRU_BASE)
+
+static u32 CRU_PCLK_REG30;
+static u32 CRU_CLK_OUT;
+static u32 clk_cif_out_src_gate_en;
+static u32 CRU_CLKSEL29_CON;
+static u32 cif0_clk_sel;
+static u32 ENANABLE_INVERT_PCLK_CIF0;
+static u32 DISABLE_INVERT_PCLK_CIF0;
+static u32 ENANABLE_INVERT_PCLK_CIF1;
+static u32 DISABLE_INVERT_PCLK_CIF1;
+static u32 CHIP_NAME;
+
+extern void rk_camera_cif_iomux(int cif_index);
+static int cif_io_mux(void)
+{
+    if(CHIP_NAME == 3288){
+        __raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0380);
+    }else if(CHIP_NAME == 3368){
+        //__raw_writel(((1<<1)|(1<<(1+16))),RK_GRF_VIRT+0x0900);
+        __raw_writel(((1<<1)|(1<<(1+16))),CRU_BASE+0x0900);
+    } else if (CHIP_NAME == 3228) {
+        /* grf_cif_io_sel:select cifio_m1,done by pinctrl */
+        /* __raw_writel(((1<<25)|(1<<9)),rk_cif_grf_base+0x0050); */
+    }
+	/*  pinctrl has been set by vehicle_main when parse dt */
+
+	return 0;
+}
+
+static int cif_init_buffer(struct vehicle_cif *cif);
+
+static void cif_dump_regs(struct vehicle_cif *cif)
+{
+	int val = read_cif_reg(cif->base, CIF_CIF_CTRL);
+
+	if (0)
+		return;
+
+	DBG("CIF_CIF_CTRL = 0x%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_INTEN);
+	DBG("CIF_CIF_INTEN = 0x%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_INTSTAT);
+	DBG("CIF_CIF_INTSTAT = 0x%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_FOR);
+	DBG("CIF_CIF_FOR = 0x%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_CROP);
+	DBG("CIF_CIF_CROP = 0x%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_SET_SIZE);
+	DBG("CIF_CIF_SET_SIZE = 0x%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_SCL_CTRL);
+	DBG("CIF_CIF_SCL_CTRL = 0x%x\r\n", val);
+
+	val = read_cru_reg(CRU_PCLK_REG30);
+	DBG("CRU_PCLK_REG30 = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_LAST_LINE);
+	DBG("CIF_CIF_LAST_LINE = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_LAST_PIX);
+	DBG("CIF_CIF_LAST_PIX = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_VIR_LINE_WIDTH);
+	DBG("CIF_CIF_VIR_LINE_WIDTH = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_LINE_NUM_ADDR);
+	DBG("CIF_CIF_LINE_NUM_ADDR = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_Y);
+	DBG("CIF_CIF_FRM0_ADDR_Y = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_UV);
+	DBG("CIF_CIF_FRM0_ADDR_UV = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_Y);
+	DBG("CIF_CIF_FRM1_ADDR_Y = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_UV);
+	DBG("CIF_CIF_FRM1_ADDR_UV = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_FRAME_STATUS);
+	DBG("CIF_CIF_FRAME_STATUS = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_SCL_VALID_NUM);
+	DBG("CIF_CIF_SCL_VALID_NUM = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_CUR_DST);
+	DBG("CIF_CIF_CUR_DST = 0X%x\r\n", val);
+
+	val = read_cif_reg(cif->base, CIF_CIF_LINE_NUM_ADDR);
+	DBG("CIF_CIF_LINE_NUM_ADDR = 0X%x\r\n", val);
+}
+static void cif_reset(struct vehicle_cif  *cif, int only_rst);
+static int cif_format_setup(struct vehicle_cif *cif)
+{
+	struct vehicle_cfg *cfg = &cif->cif_cfg;
+	u32 format;
+	u32 crop;
+
+	format = (cfg->vsync | (cfg->href<<1) | (cfg->input_format<<2) |
+		  (cfg->yuv_order<<5) | (cfg->output_format<<16) |
+		  (cfg->field_order<<9));
+	crop = (cfg->start_x | (cfg->start_y<<16));
+
+   /*must do it*/
+   cif_reset(cif, 1);
+
+	write_cif_reg(cif->base, CIF_CIF_CTRL,
+		      AXI_BURST_16|MODE_PINGPONG|DISABLE_CAPTURE);
+
+	write_cif_reg(cif->base, CIF_CIF_FOR, format);
+	write_cif_reg(cif->base, CIF_CIF_INTSTAT, 0xFFFFFFFF);
+	write_cif_reg(cif->base, CIF_CIF_CROP, crop);
+	write_cif_reg(cif->base, CIF_CIF_SET_SIZE,
+		      cfg->width | (cfg->height << 16));
+	write_cif_reg(cif->base, CIF_CIF_VIR_LINE_WIDTH, cfg->width);
+	write_cif_reg(cif->base, CIF_CIF_FRAME_STATUS,  0x00000003);
+
+	/*MUST bypass scale */
+	write_cif_reg(cif->base, CIF_CIF_SCL_CTRL, 0x10);
+
+	return 0;
+}
+static int cif_s_stream(struct vehicle_cif *cif, int enable)
+{
+	int cif_ctrl_val;
+
+	cif->is_enabled = enable;
+
+	DBG("%s enable=%d\n", __func__, enable);
+	cif_ctrl_val = read_cif_reg(cif->base, CIF_CIF_CTRL);
+	if (enable) {
+		cif->irqinfo.cifirq_idx = 0;
+		cif->irqinfo.cifirq_normal_idx = 0;
+		cif->irqinfo.cifirq_abnormal_idx = 0;
+		cif->irqinfo.dmairq_idx = 0;
+		write_cif_reg(cif->base, CIF_CIF_INTEN, 0x01|0x200);
+		cif_ctrl_val |= ENABLE_CAPTURE;
+		write_cif_reg(cif->base, CIF_CIF_CTRL, cif_ctrl_val);
+	} else {
+		cif_ctrl_val &= ~ENABLE_CAPTURE;
+		write_cif_reg(cif->base, CIF_CIF_CTRL, cif_ctrl_val);
+		write_cif_reg(cif->base, CIF_CIF_INTEN, 0);
+	}
+	DBG("%s enable=%d succeed\n", __func__, enable);
+
+	return 0;
+}
+static void cif_cru_set_soft_reset(u32 idx, int on , u32 RK_CRU_SOFTRST_CON)
+{
+	/* dsb(sy); */
+    u32 val = 0;
+    void __iomem *reg;
+
+    //reg = (void*)(CRU_BASE + RK_CRU_SOFTRST_CON);
+
+    printk("%s: CHIP_NAME == %d\n", __func__, CHIP_NAME);
+    if (CHIP_NAME == 3368 || CHIP_NAME == 3228)
+        reg = (void*)(CRU_BASE + RK_CRU_SOFTRST_CON);
+    else
+        reg = (void*)(RK_CRU_VIRT + RK_CRU_SOFTRST_CON);
+
+    if(CHIP_NAME == 3126){
+        val = on ? 0x10001U << 14 : 0x10000U << 14;
+    }else if(CHIP_NAME == 3288){
+        val = on ? 0x10001U << 8 : 0x10000U << 8;
+    }else if(CHIP_NAME == 3368){
+        val = on ? 0x10001U << 8 : 0x10000U << 8;
+    } else if (CHIP_NAME == 3228) {
+        val = on ? 0x00380038 : 0x00380000U;
+    }
+    writel_relaxed(val, reg);
+    dsb(sy);	
+}
+
+static void cif_reset(struct vehicle_cif  *cif, int only_rst)
+{
+	int ctrl_reg, inten_reg, crop_reg, set_size_reg, for_reg;
+	int vir_line_width_reg, scl_reg;
+	int y0_reg, uv0_reg, y1_reg, uv1_reg;
+
+	u32 RK_CRU_SOFTRST_CON = 0;
+
+    if(CHIP_NAME == 3126) {
+        RK_CRU_SOFTRST_CON = RK312X_CRU_SOFTRSTS_CON(6);
+    } else if (CHIP_NAME == 3228) {
+        RK_CRU_SOFTRST_CON = 0x0324;
+    }else if(CHIP_NAME == 3288) {
+        RK_CRU_SOFTRST_CON = RK3288_CRU_SOFTRSTS_CON(6);
+    }else if(CHIP_NAME == 3368) {
+        RK_CRU_SOFTRST_CON = RK3368_CRU_SOFTRSTS_CON(6);
+    }
+
+	if (only_rst == 1) {
+		cif_cru_set_soft_reset(0, 1, RK_CRU_SOFTRST_CON);
+		udelay(5);
+		cif_cru_set_soft_reset(0, 0, RK_CRU_SOFTRST_CON);
+	} else {
+		ctrl_reg = read_cif_reg(cif->base, CIF_CIF_CTRL);
+		if (ctrl_reg & ENABLE_CAPTURE)
+			write_cif_reg(cif->base, CIF_CIF_CTRL,
+				      ctrl_reg & ~ENABLE_CAPTURE);
+
+		crop_reg = read_cif_reg(cif->base, CIF_CIF_CROP);
+		set_size_reg = read_cif_reg(cif->base, CIF_CIF_SET_SIZE);
+		inten_reg = read_cif_reg(cif->base, CIF_CIF_INTEN);
+		for_reg = read_cif_reg(cif->base, CIF_CIF_FOR);
+		vir_line_width_reg = read_cif_reg(cif->base,
+						  CIF_CIF_VIR_LINE_WIDTH);
+		scl_reg = read_cif_reg(cif->base, CIF_CIF_SCL_CTRL);
+		y0_reg = read_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_Y);
+		uv0_reg = read_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_UV);
+		y1_reg = read_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_Y);
+		uv1_reg = read_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_UV);
+
+		cif_cru_set_soft_reset(0, 1, RK_CRU_SOFTRST_CON);
+		udelay(5);
+		cif_cru_set_soft_reset(0, 0, RK_CRU_SOFTRST_CON);
+
+		write_cif_reg(cif->base, CIF_CIF_CTRL,
+			      ctrl_reg & ~ENABLE_CAPTURE);
+		write_cif_reg(cif->base, CIF_CIF_INTEN, inten_reg);
+		write_cif_reg(cif->base, CIF_CIF_CROP, crop_reg);
+		write_cif_reg(cif->base, CIF_CIF_SET_SIZE, set_size_reg);
+		write_cif_reg(cif->base, CIF_CIF_FOR, for_reg);
+		write_cif_reg(cif->base, CIF_CIF_VIR_LINE_WIDTH,
+			      vir_line_width_reg);
+		write_cif_reg(cif->base, CIF_CIF_SCL_CTRL, scl_reg);
+		write_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_Y, y0_reg);
+		write_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_UV, uv0_reg);
+		write_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_Y, y1_reg);
+		write_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_UV, uv1_reg);
+
+		write_cif_reg(cif->base, CIF_CIF_FRAME_STATUS,  0x00000003);
+	}
+	dsb(sy);  
+}
+
+static void cif_reset_delay(struct vehicle_cif *cif)
+{
+	DBG("%s\n", __func__);
+	mdelay(1);
+	cif_reset(cif, 0);
+	mdelay(1);
+  
+    if (cif->is_enabled)
+	    cif_s_stream(cif, 1);
+	DBG("%s succeed\n", __func__);
+}
+
+void cif_capture_en(char *reg, int enable)
+{
+	int val = 0;
+
+	val = read_cif_reg(reg, CIF_CIF_CTRL);
+	if (enable == 1)
+		write_cif_reg(reg, CIF_CIF_CTRL, val|0x01);
+	else
+		write_cif_reg(reg, CIF_CIF_CTRL, val&(~0x01));
+}
+
+#define UV_OFFSET (cif->cif_cfg.width * cif->cif_cfg.height)
+static int cif_init_buffer(struct vehicle_cif  *cif)
+{
+	u8 i;
+	unsigned long y_addr, uv_addr;
+
+	if (cif->cif_cfg.buf_num < 2)
+		return -1;
+
+	if (cif->cif_cfg.buf_num > MAX_BUF_NUM)
+		cif->cif_cfg.buf_num = MAX_BUF_NUM;
+
+	for (i = 0 ; i < cif->cif_cfg.buf_num; i++) {
+		cif->frame_buf[i] = cif->cif_cfg.buf_phy_addr[i];
+		if (cif->frame_buf[i] == 0)
+			return -1;
+	}
+
+	cif->last_buf_index = 0;
+	cif->current_buf_index = 1;
+
+	/*y_addr = cif->frame_buf[0];*/
+	y_addr = vehicle_flinger_request_cif_buffer(0);
+	uv_addr = y_addr + UV_OFFSET;
+	write_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_Y, y_addr);
+	write_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_UV, uv_addr);
+	cif->active[0] = y_addr;
+
+	/*y_addr = cif->frame_buf[1];*/
+	y_addr = vehicle_flinger_request_cif_buffer(1);
+	uv_addr = y_addr + UV_OFFSET;
+	write_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_Y, y_addr);
+	write_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_UV, uv_addr);
+	cif->active[1] = y_addr;
+
+	return 0;
+}
+
+int cif_next_buffer(struct vehicle_cif *cif, u32 frame_ready)
+{
+	unsigned long y_addr, uv_addr;
+
+	if ((frame_ready > 1) || (cif->cif_cfg.buf_num < 2) ||
+	    (cif->cif_cfg.buf_num > MAX_BUF_NUM))
+		return 0;
+
+	cif->last_buf_index = cif->current_buf_index;
+	cif->current_buf_index = (cif->current_buf_index + 1) %
+				 cif->cif_cfg.buf_num;
+
+	/*y_addr = cif->frame_buf[cif->current_buf_index];*/
+	y_addr = vehicle_flinger_request_cif_buffer(frame_ready);
+	if (y_addr == 0) {
+		DBG("%s, warnning request buffer failed\n", __func__);
+		return -1;
+	}
+	uv_addr = y_addr + UV_OFFSET;
+	if (frame_ready == 0) {
+		write_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_Y, y_addr);
+		write_cif_reg(cif->base, CIF_CIF_FRM0_ADDR_UV, uv_addr);
+		cif->active[0] = y_addr;
+	} else {
+		write_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_Y, y_addr);
+		write_cif_reg(cif->base, CIF_CIF_FRM1_ADDR_UV, uv_addr);
+		cif->active[1] = y_addr;
+	}
+
+	return 0;
+}
+
+int cif_irq_error_process(struct vehicle_cif *cif, unsigned int reg_intstat)
+{
+    if (CHIP_NAME == 3368) {
+      	if ((reg_intstat & LINE_ERR) || (reg_intstat & PIX_ERR) ||
+      	    (reg_intstat & IFIFO_OF) || (reg_intstat & DFIFO_OF)) {
+      		DBG("irq ERROR %x\r\n", reg_intstat);
+      		return -2;
+      	}
+    } else if (CHIP_NAME == 3126) {
+      if ((reg_intstat & 0x1) == 0 && ((reg_intstat & LINE_ERR) || (reg_intstat & PIX_ERR) ||
+          (reg_intstat & IFIFO_OF) || (reg_intstat & DFIFO_OF))) {
+        DBG("irq ERROR %x\r\n", reg_intstat);
+        return -2;
+      }
+   }
+	return 0;
+}
+
+static void cif_reset_work_func(struct work_struct *work)
+{
+	struct vehicle_cif *cif = container_of(work, struct vehicle_cif,
+			work.work);
+	cif_reset_delay(cif);
+}
+
+static void cif_cifirq(struct vehicle_cif  *cif)
+{
+	unsigned int reg_lastpix, reg_lastline;
+
+	/*  1. clear irq status */
+	write_cif_reg(cif->base, CIF_CIF_INTSTAT, 0x2fe);
+	reg_lastpix = read_cif_reg(cif->base, CIF_CIF_LAST_PIX);
+	reg_lastline = read_cif_reg(cif->base, CIF_CIF_LAST_LINE);
+
+	cif->irqinfo.cifirq_idx++;
+	if (reg_lastline != cif->cif_cfg.height) {
+		cif->irqinfo.cifirq_abnormal_idx = cif->irqinfo.cifirq_idx;
+		DBG("Cif irq error:abnormal_idx %ld, %dx%d != %dx%d\n",
+		    cif->irqinfo.cifirq_abnormal_idx, reg_lastpix,
+		    reg_lastline, cif->cif_cfg.width, cif->cif_cfg.height);
+	} else {
+		cif->irqinfo.cifirq_normal_idx = cif->irqinfo.cifirq_idx;
+	}
+
+	if (cif->irqinfo.cifirq_abnormal_idx > 0) {
+		if ((cif->irqinfo.cifirq_idx -
+		    cif->irqinfo.cifirq_abnormal_idx) == 1) {
+			vehicle_cif_error_notify(reg_lastline);
+			DBG("Receive cif error twice, cif reset\n");
+
+			write_cif_reg(cif->base, CIF_CIF_INTSTAT, 0x3f);
+			cif_capture_en(cif->base, 0);
+			write_cif_reg(cif->base, CIF_CIF_INTEN, 0);
+			queue_delayed_work(system_wq, &cif->work,
+					 msecs_to_jiffies(1));
+		}
+	}
+}
+
+static inline void cif_dmairq(struct vehicle_cif  *cif)
+{
+	unsigned int reg_frame_status, reg_cur_dst, reg_cifctrl;
+	int frame_ready;
+	unsigned long addr;
+
+	reg_cifctrl = read_cif_reg(cif->base, CIF_CIF_CTRL);
+	reg_frame_status = read_cif_reg(cif->base, CIF_CIF_FRAME_STATUS);
+	reg_cur_dst = read_cif_reg(cif->base, CIF_CIF_CUR_DST);
+
+	write_cif_reg(cif->base, CIF_CIF_INTSTAT, 0x01);
+
+	if (0 == cif->is_enabled) {
+		write_cif_reg(cif->base, CIF_CIF_INTEN, 0x0);
+		cif_reset(cif, true);
+		return;
+	}
+	
+	//DBG("reg_frame_status = 0x%x\n", reg_frame_status);
+	if (reg_frame_status & (CIF_F0_READY | CIF_F1_READY)) {
+		/*  1. clear irq status */
+		write_cif_reg(cif->base, CIF_CIF_INTSTAT, 0x01);
+
+		cif->irqinfo.dmairq_idx++;
+		if (cif->irqinfo.cifirq_abnormal_idx ==
+		    cif->irqinfo.dmairq_idx) {
+			write_cif_reg(cif->base, CIF_CIF_FRAME_STATUS,  0x03);
+			goto end;
+		}
+
+		/*  2. error check */
+		if ((reg_frame_status & CIF_F0_READY) &&
+		    (reg_frame_status & CIF_F1_READY)) {
+			DBG("err f0 && f1 ready\n");
+			cif_capture_en(cif->base, 0);
+			write_cif_reg(cif->base, CIF_CIF_INTEN, 0);
+			queue_delayed_work(system_wq, &cif->work,
+					 msecs_to_jiffies(1));
+			return;
+		}
+		if (reg_frame_status & CIF_F0_READY)
+			frame_ready = 0;
+		else
+			frame_ready = 1;
+
+		addr = cif->active[frame_ready];
+		if (cif_next_buffer(cif, frame_ready) < 0)
+			DBG("cif_nex_buffer error, do not commit %lx\n", addr);
+		else
+			vehicle_flinger_commit_cif_buffer(addr);
+	}
+end:
+	if ((reg_cifctrl & ENABLE_CAPTURE) == 0)
+		write_cif_reg(cif->base, CIF_CIF_CTRL,
+			      (reg_cifctrl | ENABLE_CAPTURE));
+}
+
+static irqreturn_t rk_camera_irq(int irq, void *data)
+{
+	struct vehicle_cif *cif = (struct vehicle_cif *)data;
+	int reg_intstat;
+
+	reg_intstat = read_cif_reg(cif->base, CIF_CIF_INTSTAT);
+
+	/*DBG("%s reg_intstat 0x%x\n", __func__, reg_intstat);*/
+
+	if (cif->is_enabled == 0) {
+		DBG("INTSTAT = %x\n", reg_intstat);
+		write_cif_reg(cif->base,CIF_CIF_INTSTAT,0xffffffff);
+		goto IRQ_EXIT;
+   }
+		/* error process */
+	if (cif_irq_error_process(cif, reg_intstat) < 0) {
+		DBG("irq error, to do... reset, intstat=%x\n", reg_intstat);
+		write_cif_reg(cif->base,CIF_CIF_INTSTAT,0xffffffff);
+		cif_capture_en(cif->base, 0);
+		write_cif_reg(cif->base, CIF_CIF_INTEN, 0);
+
+		queue_delayed_work(system_wq, &cif->work,
+				 msecs_to_jiffies(1));
+		goto IRQ_EXIT;
+	}
+	/*DBG("IRQ = 0x%x\n", reg_intstat);*/
+	if (reg_intstat & 0x0200)
+		cif_cifirq(cif);
+
+	if (reg_intstat & 0x01)
+		cif_dmairq(cif);
+
+    reg_intstat = read_cif_reg(cif->base, CIF_CIF_INTSTAT);
+
+    /*DBG("%s reg_intstat 0x%x succeed\n", __func__, reg_intstat);*/
+
+IRQ_EXIT:
+	return IRQ_HANDLED;
+}
+
+static int rk_cif_mclk_ctrl(struct rk_cif_clk *clk, int on, int clk_rate)
+{
+	int err = 0;
+
+	if (!clk->aclk_cif || !clk->hclk_cif ||
+	    !clk->cif_clk_in || !clk->cif_clk_out) {
+		DBG("failed to get cif clock source\n");
+		err = -ENOENT;
+		return -1;
+	}
+
+	if (on && !clk->on) {
+        if (CHIP_NAME != 3228)
+            clk_prepare_enable(clk->pd_cif);
+        if (CHIP_NAME == 3368)
+            clk_prepare_enable(clk->pclk_cif);
+		clk_prepare_enable(clk->aclk_cif);
+		clk_prepare_enable(clk->hclk_cif);
+        if (CHIP_NAME != 3228)
+            clk_prepare_enable(clk->cif_clk_in);
+		clk_prepare_enable(clk->cif_clk_out);
+		clk_set_rate(clk->cif_clk_out, clk_rate);
+		clk->on = true;
+	} else if (!on && clk->on) {
+		clk_set_rate(clk->cif_clk_out, 36000000);
+		clk_disable_unprepare(clk->aclk_cif);
+		clk_disable_unprepare(clk->hclk_cif);
+        if (CHIP_NAME != 3228)
+            clk_disable_unprepare(clk->cif_clk_in);
+        if (CHIP_NAME == 3126) {
+            write_cru_reg(CRU_CLKSEL29_CON, 0x007c0000);
+            write_cru_reg(CRU_CLK_OUT, 0x00800080);
+        }
+		clk_disable_unprepare(clk->cif_clk_out);
+        if (CHIP_NAME != 3228)
+            clk_disable_unprepare(clk->pd_cif);
+        if (CHIP_NAME == 3368)
+            clk_disable_unprepare(clk->pclk_cif);
+
+		clk->on = false;
+	}
+
+	return err;
+}
+
+int vehicle_cif_reverse_open(struct vehicle_cfg *v_cfg)
+{
+	struct vehicle_cif *cif = g_cif;
+
+	if (!cif)
+		return -1;
+
+	DBG("%s\n", __func__);
+
+	memcpy(&cif->cif_cfg, v_cfg, sizeof(struct vehicle_cfg));
+
+	/*  1. format setup */
+	cif_format_setup(cif);
+
+	/*  2. cif init buffer */
+	if (cif_init_buffer(cif) < 0)
+		return -1;
+
+	cif_dump_regs(cif);
+
+	/*  3. start stream */
+	cif_s_stream(cif, 1);
+
+	DBG("%s succeed\n", __func__);
+
+	return 0;
+}
+
+int vehicle_cif_reverse_close(void)
+{
+	if (!g_cif)
+		return -1;
+	DBG("%s \n", __func__);
+
+	cif_s_stream(g_cif, 0);
+	DBG("%s succeed\n", __func__);
+
+	return 0;
+}
+
+static void rk_camera_diffchips(const char *rockchip_name)
+{
+    if(strstr(rockchip_name, "3128")||
+	   strstr(rockchip_name, "3126")||
+	   strstr(rockchip_name, "px3se"))
+    {
+        CRU_PCLK_REG30 = 0xbc;
+        ENANABLE_INVERT_PCLK_CIF0 = ((0x1<<23)|(0x1<<7));
+        DISABLE_INVERT_PCLK_CIF0  = ((0x1<<23)|(0x0<<7));
+        ENANABLE_INVERT_PCLK_CIF1 = ENANABLE_INVERT_PCLK_CIF0;
+        DISABLE_INVERT_PCLK_CIF1  = DISABLE_INVERT_PCLK_CIF0;
+
+        CRU_CLK_OUT = 0xdc;
+        clk_cif_out_src_gate_en = ((0x1<<23)|(0x1<<7));
+        CRU_CLKSEL29_CON = 0xb8;
+        cif0_clk_sel = ((0x1<<23)|(0x0<<7));
+
+        CHIP_NAME = 3126;
+    }
+    else if(strstr(rockchip_name,"3288"))
+    {
+        CRU_PCLK_REG30 = 0xd4;
+        ENANABLE_INVERT_PCLK_CIF0 = ((0x1<<20)|(0x1<<4));
+        DISABLE_INVERT_PCLK_CIF0  = ((0x1<<20)|(0x0<<4));
+        ENANABLE_INVERT_PCLK_CIF1 = ENANABLE_INVERT_PCLK_CIF0;
+        DISABLE_INVERT_PCLK_CIF1  = DISABLE_INVERT_PCLK_CIF0;
+
+        CRU_CLK_OUT = 0x16c;
+        CHIP_NAME = 3288;
+    } else if (strstr(rockchip_name, "3368") ||
+           strstr(rockchip_name, "px5"))
+    {
+        CRU_PCLK_REG30 = 0x154;
+        ENANABLE_INVERT_PCLK_CIF0 = ((0x1<<29)|(0x1<<13));
+        DISABLE_INVERT_PCLK_CIF0  = ((0x1<<29)|(0x0<<13));
+        ENANABLE_INVERT_PCLK_CIF1 = ENANABLE_INVERT_PCLK_CIF0;
+        DISABLE_INVERT_PCLK_CIF1  = DISABLE_INVERT_PCLK_CIF0;
+
+        //CRU_CLK_OUT = 0x16c;
+        CHIP_NAME = 3368;
+    } else if (strstr(rockchip_name, "3228h")) {
+        CRU_PCLK_REG30 = 0x0410;
+        ENANABLE_INVERT_PCLK_CIF0 = ((0x1<<31)|(0x1<<15));
+        DISABLE_INVERT_PCLK_CIF0  = ((0x1<<31)|(0x0<<15));
+        ENANABLE_INVERT_PCLK_CIF1 = ENANABLE_INVERT_PCLK_CIF0;
+        DISABLE_INVERT_PCLK_CIF1  = DISABLE_INVERT_PCLK_CIF0;
+        CHIP_NAME = 3228;
+    }
+}
+
+static int cif_parse_dt(struct vehicle_cif *cif)
+{
+	struct device *dev = cif->dev;
+	struct device_node *node;
+	struct device_node *cif_node;
+	const char *compatible = NULL;
+	int err;
+
+    err = of_property_read_string(dev->of_node->parent,"compatible",&compatible);
+	if(err < 0) {
+		DBG("Get compatible failed\n");
+		return -1;
+	}
+
+	rk_camera_diffchips(compatible);
+
+	DBG("%s:compatible %s, CHIP NAME %d\n", __func__, compatible, CHIP_NAME);
+
+	if (of_property_read_u32(dev->of_node, "cif,drop-frames",
+				 &cif->drop_frames)) {
+		DBG("%s:Get cif, drop-frames failed!\n", __func__);
+	}
+
+	cif_node = of_parse_phandle(dev->of_node, "rockchip,cif", 0);
+	cif->base = (char *)of_iomap(cif_node, 0);
+
+	node = of_parse_phandle(dev->of_node, "rockchip,cru", 0);
+	if (node)
+		cif->cru_base = (unsigned long)of_iomap(node, 0);
+	else
+		cif->cru_base = (unsigned long)RK_CRU_VIRT;
+
+	node = of_parse_phandle(dev->of_node, "rockchip,grf", 0);
+	if (node)
+		cif->grf_base = (unsigned long)of_iomap(node, 0);
+
+	cif->irq = irq_of_parse_and_map(cif_node, 0);
+	if (cif->irq < 0) {
+		DBG("%s: request irq failed\n", __func__);
+		return -1;
+	}
+
+	DBG("%s, drop_frames = %d\n", __func__, cif->drop_frames);
+	return 0;
+}
+int	vehicle_cif_init(struct vehicle_cif *cif)
+{
+	int ret;
+	struct device *dev = cif->dev;
+	struct rk_cif_clk *clk = &cif->clk;
+
+	if (!cif)
+		return -1;
+
+	g_cif = cif;
+
+	if (cif_parse_dt(cif) < -1) {
+		DBG("%s: cif_parse_dt failed\n", __func__);
+		return -1;
+	}
+
+	/*  init addr */
+	/* cif->base = ioremap(BASE_CIF, REG_LEN); */
+
+	/*  1. iomux */
+	cif_io_mux();
+
+	/*  2. cif clk setup */
+	if (1) {//IS_CIF0()) {
+		if (CHIP_NAME != 3228)
+			clk->pd_cif = devm_clk_get(dev, "pd_cif0");
+		if (CHIP_NAME == 3368)
+			clk->pclk_cif = devm_clk_get(dev, "pclk_cif");
+		clk->aclk_cif = devm_clk_get(dev, "aclk_cif0");
+		clk->hclk_cif = devm_clk_get(dev, "hclk_cif0");
+		if (CHIP_NAME != 3228)
+			clk->cif_clk_in = devm_clk_get(dev, "cif0_in");
+		clk->cif_clk_out = devm_clk_get(dev, "cif0_out");
+	} else {
+        if (CHIP_NAME != 3368 && CHIP_NAME != 3228)
+            clk->pd_cif = devm_clk_get(dev, "pd_cif0");/*cif0  only */
+
+        clk->aclk_cif = devm_clk_get(dev, "aclk_cif0");
+        clk->hclk_cif = devm_clk_get(dev, "hclk_cif0");
+        if (CHIP_NAME != 3228)
+            clk->cif_clk_in = devm_clk_get(dev, "cif0_in");
+        clk->cif_clk_out = devm_clk_get(dev, "cif0_out");
+    }
+
+	/*  2. set cif clk */
+	rk_cif_mclk_ctrl(clk, 1, 24000000);
+
+	INIT_DELAYED_WORK(&cif->work, cif_reset_work_func);
+
+	/*  3. request irq */
+	ret = request_irq(cif->irq, rk_camera_irq, IRQF_SHARED, "veh_cif", cif);
+	if (ret < 0) {
+		DBG("yuyz test: request cif irq\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+int vehicle_cif_deinit(struct vehicle_cif *cif)
+{
+	struct rk_cif_clk *clk = &cif->clk;
+	struct device *dev = cif->dev;
+
+	cif_s_stream(cif, 0);
+
+	rk_cif_mclk_ctrl(clk, 0, 0);
+
+	if (CHIP_NAME != 3228)
+		devm_clk_put(dev, clk->pd_cif);
+	if (CHIP_NAME == 3368)
+		devm_clk_put(dev, clk->pclk_cif);
+	if (CHIP_NAME != 3228)
+		devm_clk_put(dev, clk->cif_clk_in);
+	devm_clk_put(dev, clk->aclk_cif);
+	devm_clk_put(dev, clk->hclk_cif);
+	devm_clk_put(dev, clk->cif_clk_out);
+
+	free_irq(cif->irq, cif);
+	return 0;
+}
diff --git a/drivers/video/rockchip/vehicle/vehicle_cif.h b/drivers/video/rockchip/vehicle/vehicle_cif.h
new file mode 100755
index 0000000..49e4ba0
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_cif.h
@@ -0,0 +1,176 @@
+#ifndef __VEHICLE_CIF_H
+#define __VEHICLE_CIF_H
+
+#include "vehicle_cfg.h"
+
+struct rk_cif_clk {
+	/************must modify start************/
+	struct clk *pd_cif;
+	struct clk *aclk_cif;
+	struct clk *hclk_cif;
+	struct clk *cif_clk_in;
+	struct clk *cif_clk_out;
+	struct clk *pclk_cif;
+	/************must modify end************/
+
+	/*  spinlock_t lock; */
+	bool on;
+};
+
+struct rk_cif_irqinfo {
+	unsigned int irq;
+	unsigned long cifirq_idx;
+	unsigned long cifirq_normal_idx;
+	unsigned long cifirq_abnormal_idx;
+
+	unsigned long dmairq_idx;
+};
+
+struct vehicle_cif {
+	struct device *dev;
+	struct rk_cif_clk clk;
+	struct vehicle_cfg cif_cfg;
+	char *base;  /*cif base addr*/
+	unsigned long cru_base;
+	unsigned long grf_base;
+	struct delayed_work work;
+
+	bool is_enabled;
+	u32 frame_buf[MAX_BUF_NUM];
+	u32 current_buf_index;
+	u32 last_buf_index;
+	u32 active[2];
+	int irq;
+	int drop_frames;
+	struct rk_cif_irqinfo irqinfo;
+};
+
+int vehicle_cif_init(struct vehicle_cif *cif);
+int vehicle_cif_deinit(struct vehicle_cif *cif);
+
+int vehicle_cif_reverse_open(struct vehicle_cfg *v_cfg);
+
+int vehicle_cif_reverse_close(void);
+
+/* CIF IRQ STAT*/
+#define DMA_FRAME_END					(0x01 << 0)
+#define LINE_END						(0x01 << 1)
+#define LINE_ERR						(0x01 << 2)
+#define PIX_ERR							(0x01 << 3)
+#define IFIFO_OF						(0x01 << 4)
+#define DFIFO_OF						(0x01 << 5)
+#define BUS_ERR							(0x01 << 6)
+#define PRE_INF_FRAME_END				(0x01 << 8)
+#define PST_INF_FRAME_END				(0x01 << 9)
+
+/* CIF Reg Offset*/
+#define  CIF_CIF_CTRL               0x00
+#define  CIF_CIF_INTEN              0x04
+#define  CIF_CIF_INTSTAT            0x08
+#define  CIF_CIF_FOR            0x0c
+#define  CIF_CIF_LINE_NUM_ADDR          0x10
+#define  CIF_CIF_FRM0_ADDR_Y        0x14
+#define  CIF_CIF_FRM0_ADDR_UV           0x18
+#define  CIF_CIF_FRM1_ADDR_Y        0x1c
+#define  CIF_CIF_FRM1_ADDR_UV           0x20
+#define  CIF_CIF_VIR_LINE_WIDTH         0x24
+#define  CIF_CIF_SET_SIZE           0x28
+#define  CIF_CIF_SCM_ADDR_Y         0x2c
+#define  CIF_CIF_SCM_ADDR_U         0x30
+#define  CIF_CIF_SCM_ADDR_V         0x34
+#define  CIF_CIF_WB_UP_FILTER           0x38
+#define  CIF_CIF_WB_LOW_FILTER          0x3c
+#define  CIF_CIF_WBC_CNT            0x40
+#define  CIF_CIF_CROP               0x44
+#define  CIF_CIF_SCL_CTRL           0x48
+#define	 CIF_CIF_SCL_DST            0x4c
+#define	 CIF_CIF_SCL_FCT            0x50
+#define	 CIF_CIF_SCL_VALID_NUM          0x54
+#define	 CIF_CIF_LINE_LOOP_CTR          0x58
+#define	 CIF_CIF_FRAME_STATUS           0x60
+#define	 CIF_CIF_CUR_DST            0x64
+#define	 CIF_CIF_LAST_LINE          0x68
+#define	 CIF_CIF_LAST_PIX           0x6c
+
+/*The key register bit descrition*/
+/* CIF_CTRL Reg , ignore SCM, WBC, ISP, */
+#define  DISABLE_CAPTURE          (0x00<<0)
+#define  ENABLE_CAPTURE           (0x01<<0)
+#define  MODE_ONEFRAME        (0x00<<1)
+#define  MODE_PINGPONG        (0x01<<1)
+#define  MODE_LINELOOP        (0x02<<1)
+#define  AXI_BURST_16         (0x0F << 12)
+
+/*CIF_CIF_INTEN*/
+#define  FRAME_END_EN			(0x01<<1)
+#define  BUS_ERR_EN				(0x01<<6)
+#define  SCL_ERR_EN				(0x01<<7)
+
+/* CIF_CIF_FRAME_STATUS */
+#define CIF_F0_READY (0x01<<0)
+#define CIF_F1_READY (0x01<<1)
+
+/*CIF_CIF_FOR*/
+#define  VSY_HIGH_ACTIVE           (0x01<<0)
+#define  VSY_LOW_ACTIVE            (0x00<<0)
+#define  HSY_LOW_ACTIVE				(0x01<<1)
+#define  HSY_HIGH_ACTIVE			(0x00<<1)
+#define  INPUT_MODE_YUV				(0x00<<2)
+#define  INPUT_MODE_PAL				(0x02<<2)
+#define  INPUT_MODE_NTSC			(0x03<<2)
+#define  INPUT_MODE_RAW				(0x04<<2)
+#define  INPUT_MODE_JPEG			(0x05<<2)
+#define  INPUT_MODE_MIPI			(0x06<<2)
+#define  YUV_INPUT_ORDER_UYVY(ori)   (ori & (~(0x03<<5)))
+#define  YUV_INPUT_ORDER_YVYU(ori)   ((ori & (~(0x01<<6)))|(0x01<<5))
+#define  YUV_INPUT_ORDER_VYUY(ori)   ((ori & (~(0x01<<5))) | (0x1<<6))
+#define  YUV_INPUT_ORDER_YUYV(ori)		   (ori|(0x03<<5))
+#define  YUV_INPUT_422		           (0x00<<7)
+#define  YUV_INPUT_420		           (0x01<<7)
+#define  INPUT_420_ORDER_EVEN		       (0x00<<8)
+#define  INPUT_420_ORDER_ODD		       (0x01<<8)
+#define  CCIR_INPUT_ORDER_ODD		       (0x00<<9)
+#define  CCIR_INPUT_ORDER_EVEN         (0x01<<9)
+#define  RAW_DATA_WIDTH_8          (0x00<<11)
+#define  RAW_DATA_WIDTH_10         (0x01<<11)
+#define  RAW_DATA_WIDTH_12         (0x02<<11)
+#define  YUV_OUTPUT_422            (0x00<<16)
+#define  YUV_OUTPUT_420            (0x01<<16)
+#define  OUTPUT_420_ORDER_EVEN         (0x00<<17)
+#define  OUTPUT_420_ORDER_ODD          (0x01<<17)
+#define  RAWD_DATA_LITTLE_ENDIAN       (0x00<<18)
+#define  RAWD_DATA_BIG_ENDIAN          (0x01<<18)
+#define  UV_STORAGE_ORDER_UVUV         (0x00<<19)
+#define  UV_STORAGE_ORDER_VUVU         (0x01<<19)
+
+/*CIF_CIF_SCL_CTRL*/
+#define ENABLE_SCL_DOWN            (0x01<<0)
+#define DISABLE_SCL_DOWN           (0x00<<0)
+#define ENABLE_SCL_UP              (0x01<<1)
+#define DISABLE_SCL_UP             (0x00<<1)
+#define ENABLE_YUV_16BIT_BYPASS        (0x01<<4)
+#define DISABLE_YUV_16BIT_BYPASS       (0x00<<4)
+#define ENABLE_RAW_16BIT_BYPASS        (0x01<<5)
+#define DISABLE_RAW_16BIT_BYPASS       (0x00<<5)
+#define ENABLE_32BIT_BYPASS        (0x01<<6)
+#define DISABLE_32BIT_BYPASS           (0x00<<6)
+
+enum rk_camera_signal_polarity {
+	RK_CAMERA_DEVICE_SIGNAL_HIGH_LEVEL = 1,
+	RK_CAMERA_DEVICE_SIGNAL_LOW_LEVEL = 0,
+};
+enum rk_camera_device_type {
+	RK_CAMERA_DEVICE_BT601_8	= 0x10000011,
+	RK_CAMERA_DEVICE_BT601_10	= 0x10000012,
+	RK_CAMERA_DEVICE_BT601_12	= 0x10000014,
+	RK_CAMERA_DEVICE_BT601_16	= 0x10000018,
+
+	RK_CAMERA_DEVICE_BT656_8	= 0x10000021,
+	RK_CAMERA_DEVICE_BT656_10	= 0x10000022,
+	RK_CAMERA_DEVICE_BT656_12	= 0x10000024,
+	RK_CAMERA_DEVICE_BT656_16	= 0x10000028,
+
+	RK_CAMERA_DEVICE_CVBS_NTSC	= 0x20000001,
+	RK_CAMERA_DEVICE_CVBS_PAL	= 0x20000002
+};
+#endif
diff --git a/drivers/video/rockchip/vehicle/vehicle_dev.c b/drivers/video/rockchip/vehicle/vehicle_dev.c
new file mode 100644
index 0000000..a9dfd26
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_dev.c
@@ -0,0 +1,106 @@
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/fcntl.h>
+#include <linux/mm.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/bitops.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include "vehicle_main.h"
+#include "vehicle_cfg.h"
+
+int vechile_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+int vechile_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t vechile_write(struct file *filp, const char __user *buf,
+			     size_t size, loff_t *ppos) {
+	int data = 0, ret = 0;
+
+	if (strncmp(buf, "88", size < 2 ? size : 2) == 0) {
+		vehicle_exit_notify();
+		pr_err("android already up, request vehicle exit\n");
+		return size;
+	}
+
+	ret = copy_from_user(&data, buf, sizeof(int));
+	if (ret)
+		return -1;
+
+	return 1;
+}
+
+static ssize_t
+vechile_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) {
+	return 1;
+}
+
+static const struct file_operations vechile_fops = {
+	.owner      = THIS_MODULE,
+	/*.compat_ioctl      = vechile_ioctl,*/
+	.open       = vechile_open,
+	.release    = vechile_close,
+	.write  = vechile_write,
+	.read = vechile_read,
+};
+
+static struct miscdevice vechile_dev = {
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "vehicle",
+	.fops		= &vechile_fops,
+};
+
+static int __init vechile_module_init(void)
+{
+	int ret = 0;
+	/*     unsigned char i2c_addr; */
+
+	/* register misc device*/
+	ret = misc_register(&vechile_dev);
+	if (ret) {
+		DBG("ERROR: could not register vechile dev\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit vechile_module_exit(void)
+{
+	misc_deregister(&vechile_dev);
+}
+
+module_init(vechile_module_init);
+module_exit(vechile_module_exit);
+
+#ifdef MODULE
+#include <linux/compile.h>
+#endif
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_flinger.c b/drivers/video/rockchip/vehicle/vehicle_flinger.c
new file mode 100755
index 0000000..1ef6ac8
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_flinger.c
@@ -0,0 +1,1648 @@
+/*
+ * drivers/video/rockchip/flinger/flinger.c
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co.Ltd
+ * Authors:
+ *      Zhiqin Wei <wzq@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/atomic.h>
+#include <linux/rk_fb.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kthread.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <asm/div64.h>
+#include <linux/uaccess.h>
+#include <linux/rk_fb.h>
+#include <linux/linux_logo.h>
+#include <linux/dma-mapping.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_address.h>
+#include <linux/memblock.h>
+#include <linux/kthread.h>
+#include <linux/fdtable.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+
+#ifdef CONFIG_OF
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <video/of_display_timing.h>
+#include <video/display_timing.h>
+#endif
+
+#if defined(CONFIG_ION_ROCKCHIP)
+#include <linux/rockchip_ion.h>
+#include <linux/rockchip-iovmm.h>
+#include <linux/dma-buf.h>
+#include <linux/highmem.h>
+#endif
+
+#include "../rga/rga.h"
+#include "../iep/iep.h"
+#include "vehicle_flinger.h"
+#include <linux/rk_fb.h>
+
+#define USE_COTINUE_BUFFER 0
+
+enum force_value {
+	FORCE_WIDTH = 1280,
+	FORCE_HEIGHT = 720,
+	FORCE_STRIDE = 1280,
+	FORCE_XOFFSET = 0,
+	FORCE_YOFFSET = 0,
+	FORCE_FORMAT = HAL_PIXEL_FORMAT_YCrCb_NV12,
+	FORCE_ROTATION = RGA_TRANSFORM_ROT_270,
+};
+
+#define FIX_SOURCE_BUFFER /*cif pingpong mode, fix 2 src buffer*/
+#define RK312X_RGA /*do not support yuv2yuv rotate, support yuv2rga rotate*/
+
+#ifdef FIX_SOURCE_BUFFER
+enum {
+	NUM_SOURCE_BUFFERS = 2, /*2 src buffer for cif*/
+	NUM_TARGET_BUFFERS = 3, /*3 dst buffer , 1 ipp*/
+};
+#else
+enum {
+	NUM_SOURCE_BUFFERS = 4, /*4 src buffer for cif*/
+	NUM_TARGET_BUFFERS = 5, /*4 dst buffer rga, 1 eip*/
+};
+#endif
+
+enum buffer_state {
+	UNKNOW = 0,
+	FREE,
+	DEQUEUE,
+	QUEUE,
+	ACQUIRE,
+	DISPLAY,
+};
+
+struct rect {
+	size_t x;
+	size_t y;
+	size_t w;
+	size_t h;
+	size_t s;
+	size_t f;
+};
+
+struct graphic_buffer {
+	struct list_head list;
+	struct ion_handle *handle;
+	struct sync_fence *rel_fence;
+	struct rect src;
+	struct rect dst;
+	enum buffer_state state;
+	unsigned long phy_addr;
+	void *vir_addr;
+	int ion_hnd_fd;
+	int rotation;
+	int offset;
+	int len;
+	int width;
+	int height;
+	int stride;
+	int format;
+	struct work_struct render_work;
+};
+
+struct queue_buffer {
+	struct list_head list;
+	struct graphic_buffer *buffer;
+};
+
+struct flinger {
+	struct device *dev;
+	struct ion_client *ion_client;
+	struct work_struct init_work;
+	struct work_struct render_work;
+	struct workqueue_struct *render_workqueue;
+	struct mutex source_buffer_lock;/*src buffer lock*/
+	struct mutex target_buffer_lock;/*dst buffer lock*/
+	struct graphic_buffer source_buffer[NUM_SOURCE_BUFFERS];
+	struct graphic_buffer target_buffer[NUM_TARGET_BUFFERS];
+	struct graphic_buffer cvbs_buffer;
+	struct mutex queue_buffer_lock;/*buffr queue lock*/
+	struct list_head queue_buffer_list;
+	wait_queue_head_t worker_wait;
+	atomic_t worker_cond_atomic;
+	atomic_t worker_running_atomic;
+	atomic_t souce_frame_atomic;
+	int source_index;
+	int target_index;
+	struct vehicle_cfg v_cfg;
+	int cvbs_field_count;
+	/*debug*/
+	int debug_cif_count;
+	int debug_vop_count;
+};
+
+atomic_t flinger_running;
+struct flinger *flinger = NULL;
+
+static int rk_flinger_queue_work(struct flinger *flinger,
+				 struct graphic_buffer *src_buffer);
+
+static int rk_flinger_create_ion_client(struct flinger *flinger)
+{
+	int ret = 0;
+
+	if (!flinger)
+		return -ENODEV;
+
+#if defined(CONFIG_ION_ROCKCHIP)
+	flinger->ion_client = rockchip_ion_client_create("flinger");
+	if (IS_ERR(flinger->ion_client)) {
+		DBG("wzqtest failed to create ion client for flinger");
+		return PTR_ERR(flinger->ion_client);
+	}
+#else
+	flinger->ion_client = NULL;
+	ret = -ENODEV;
+#endif
+	DBG("wzqtest %s for ret = %d\n", __func__, ret);
+	return ret;
+}
+
+static int rk_flinger_desrtoy_ion_client(struct flinger *flinger)
+{
+	int ret = 0;
+
+	DBG("wzqtest%s,%d\n", __func__, __LINE__);
+	if (!flinger)
+		return -ENODEV;
+
+#if defined(CONFIG_ION_ROCKCHIP)
+	ion_client_destroy(flinger->ion_client);
+#else
+	flinger->ion_client = NULL;
+	ret = -ENODEV;
+#endif
+	return ret;
+}
+
+static int rk_flinger_alloc_bpp(int format)
+{
+	int width = 4;
+
+	switch (format) {
+	case HAL_PIXEL_FORMAT_RGB_565:
+		width = 2;
+		break;
+	case HAL_PIXEL_FORMAT_RGB_888:
+		width =  3;
+		break;
+	case HAL_PIXEL_FORMAT_RGBA_8888:
+		width =  4;
+		break;
+	case HAL_PIXEL_FORMAT_RGBX_8888:
+		width =  4;
+		break;
+	case HAL_PIXEL_FORMAT_BGRA_8888:
+		width =  4;
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_NV12:
+		width = 2;
+       break;
+	case HAL_PIXEL_FORMAT_YCrCb_444:
+		width = 3;
+		break;
+	default:
+		DBG("%s: unsupported format: 0x%x\n", __func__, format);
+		break;
+	}
+	return width;
+}
+
+static int rk_flinger_init_buffer_dma_fd(struct flinger *flinger,
+					 struct graphic_buffer *buffer)
+{
+	struct flinger *flg = flinger;
+	int ion_hnd_fd = -1;
+
+	if (!flg)
+		return -ENODEV;
+
+	if (!buffer)
+		return -EINVAL;
+
+	if (buffer->handle && buffer->ion_hnd_fd < 0) {
+		ion_hnd_fd = ion_share_dma_buf_fd(flg->ion_client,
+						  buffer->handle);
+		if (ion_hnd_fd < 0)
+			DBG(":%s,ion_fd=%d\n", __func__, ion_hnd_fd);
+		if (ion_hnd_fd == 0) {
+			put_unused_fd(ion_hnd_fd);
+			ion_hnd_fd = get_unused_fd();
+			ion_hnd_fd = ion_share_dma_buf_fd(flinger->ion_client,
+							  buffer->handle);
+		}
+		buffer->ion_hnd_fd = ion_hnd_fd;
+	} else if (buffer->ion_hnd_fd == 0) {
+		ion_hnd_fd = buffer->ion_hnd_fd;
+		put_unused_fd(ion_hnd_fd);
+		ion_hnd_fd = get_unused_fd();
+		ion_hnd_fd = ion_share_dma_buf_fd(flinger->ion_client,
+						  buffer->handle);
+	} else {
+		ion_hnd_fd = buffer->ion_hnd_fd;
+	}
+
+	return ion_hnd_fd;
+}
+
+static int rk_flinger_get_buffer_dma_fd(struct flinger *flinger,
+					struct graphic_buffer *buffer)
+{
+	return  rk_flinger_init_buffer_dma_fd(flinger, buffer);
+}
+
+static int rk_flinger_alloc_buffer(struct flinger *flinger,
+				   struct graphic_buffer *buffer,
+				   int w, int h,
+				   int s, int f)
+{
+	ion_phys_addr_t ion_phy_addr;
+	struct ion_handle *handle;
+	unsigned long phy_addr;
+	size_t len;
+	int fd = -1, bpp;
+	int ret = 0;
+
+	if (!flinger)
+		return -ENODEV;
+
+	if (!buffer)
+		return -EINVAL;
+
+	bpp = rk_flinger_alloc_bpp(f);
+	len = s * h * bpp;
+	handle = ion_alloc(flinger->ion_client,
+			   len, 0, ION_HEAP(ION_CMA_HEAP_ID), 0);
+	if (IS_ERR(handle)) {
+		DBG("failed to ion_alloc:%ld\n", PTR_ERR(handle));
+		return -ENOMEM;
+	}
+
+	ret = ion_phys(flinger->ion_client, handle, &ion_phy_addr, &len);
+	phy_addr = ion_phy_addr;
+	buffer->vir_addr = ion_map_kernel(flinger->ion_client, handle);
+	buffer->handle = handle;
+	buffer->rel_fence = NULL;
+	buffer->phy_addr = phy_addr;
+	buffer->rotation = 0;
+	buffer->width = w;
+	buffer->height = h;
+	buffer->stride = s;
+	buffer->format = f;
+	buffer->len = len;
+	buffer->ion_hnd_fd = fd;
+
+	return 0;
+}
+
+int rk_flinger_free_buffer(struct flinger *flinger,
+			   struct graphic_buffer *buffer)
+{
+	if (!flinger)
+		return -ENODEV;
+
+	if (!buffer)
+		return -EINVAL;
+
+	if (buffer && buffer->ion_hnd_fd > -1)
+		put_unused_fd(buffer->ion_hnd_fd);
+
+	if (buffer && buffer->handle)
+		ion_free(flinger->ion_client, buffer->handle);
+
+	if (buffer && buffer->ion_hnd_fd > -1)
+		__close_fd(current->files, buffer->ion_hnd_fd);
+
+	return 0;
+}
+
+static int rk_flinger_create_worker(struct flinger *flinger)
+{
+	struct workqueue_struct *wq = NULL;
+
+	wq = create_singlethread_workqueue("flinger-render");
+	if (!wq) {
+		DBG("wzqtest Failed to create flinger workqueue\n");
+		return -ENODEV;
+	}
+	flinger->render_workqueue = wq;
+
+	return 0;
+}
+
+static int rk_flinger_destory_worker(struct flinger *flinger)
+{
+	if (!flinger)
+		return -ENODEV;
+
+	if (flinger->render_workqueue)
+		destroy_workqueue(flinger->render_workqueue);
+
+	return 0;
+}
+
+int vehicle_flinger_init(struct device *dev)
+{
+	struct graphic_buffer *buffer, *tmp;
+	struct flinger *flg = NULL;
+	int i, ret, fd, w, h, s, f;
+
+	w = FORCE_WIDTH;
+	h = FORCE_HEIGHT;
+	s = FORCE_STRIDE;
+	f = FORCE_FORMAT;
+
+	flg = kzalloc(sizeof(*flg), GFP_KERNEL);
+	if (!flg) {
+		DBG("wzqtest: %s: %d", __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&flg->queue_buffer_lock);
+	mutex_init(&flg->source_buffer_lock);
+	mutex_init(&flg->target_buffer_lock);
+	INIT_LIST_HEAD(&flg->queue_buffer_list);
+	init_waitqueue_head(&flg->worker_wait);
+	atomic_set(&flg->worker_cond_atomic, 0);
+	atomic_set(&flg->worker_running_atomic, 1);
+
+	fd = get_unused_fd();
+	DBG("wzqtest %s,%d\n", __func__, __LINE__);
+
+	ret = rk_flinger_create_ion_client(flg);
+	if (ret) {
+		DBG("wzqtest:%s: %d", __func__, __LINE__);
+		goto out;
+	}
+
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		flg->source_buffer[i].handle = NULL;
+		flg->source_buffer[i].phy_addr = 0;
+		flg->source_buffer[i].ion_hnd_fd = -1;
+	}
+	for (i = 0; i < NUM_TARGET_BUFFERS; i++) {
+		flg->target_buffer[i].handle = NULL;
+		flg->target_buffer[i].phy_addr = 0;
+		flg->target_buffer[i].ion_hnd_fd = -1;
+	}
+
+	tmp = NULL;
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		buffer = &(flg->source_buffer[i]);
+		ret = rk_flinger_alloc_buffer(flg, buffer, w, h, s, f);
+		if (ret) {
+			DBG("wzqtest:%s: %d", __func__, __LINE__);
+			goto free_dst_alloc;
+		}
+		buffer->state = FREE;
+	}
+	for (i = 0; i < NUM_TARGET_BUFFERS; i++) {
+		buffer = &(flg->target_buffer[i]);
+		ret = rk_flinger_alloc_buffer(flg, buffer, w, h, s, HAL_PIXEL_FORMAT_RGBX_8888);
+		if (ret) {
+			DBG("wzqtest:%s: %d", __func__, __LINE__);
+			goto free_src_alloc;
+		}
+		buffer->state = FREE;
+	}
+
+	/*alloc buffer for cvbs composite*/
+	buffer = &(flg->cvbs_buffer);
+	ret = rk_flinger_alloc_buffer(flg, buffer, w, h, s, f);
+	if (ret) {
+		DBG("wzqtest:%s: %d", __func__, __LINE__);
+		goto free_dst_alloc;
+	}
+	buffer->state = FREE;
+
+	ret = rk_flinger_create_worker(flg);
+	if (ret) {
+		DBG("wzqtest:%s: %d", __func__, __LINE__);
+		goto free_dst_alloc;
+	}
+	flinger = flg;
+
+	rk_flinger_queue_work(flg, NULL);
+
+	flg->dev = dev;
+	DBG("wzqtest init rk flinger ok rga\n");
+	return 0;
+free_dst_alloc:
+	for (i = 0; i < NUM_TARGET_BUFFERS; i++) {
+		ret = rk_flinger_free_buffer(flg, &(flg->target_buffer[i]));
+		if (ret)
+			DBG("wzqtest:%s: %d", __func__, __LINE__);
+	}
+free_src_alloc:
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		ret = rk_flinger_free_buffer(flg, &(flg->source_buffer[i]));
+		if (ret)
+			DBG("wzqtest:%s: %d", __func__, __LINE__);
+	}
+
+	DBG("wzqtest:%s: %d", __func__, __LINE__);
+	rk_flinger_desrtoy_ion_client(flg);
+out:
+	kfree(flg);
+	return ret;
+}
+__maybe_unused int vehicle_flinger_deinit(void)
+{
+	struct flinger *flg = flinger;
+	int i, ret;
+
+	ret = 0;
+	i = 0;
+	DBG("yuyz test %s:%d\n", __func__, __LINE__);
+	if (!flg)
+		return -ENODEV;
+
+#if 1
+	atomic_set(&flg->worker_running_atomic, 0);
+	atomic_inc(&flg->worker_cond_atomic);
+	wake_up(&flg->worker_wait);
+	flush_work(&flg->render_work);
+	flush_workqueue(flg->render_workqueue);
+	rk_flinger_destory_worker(flg);
+
+	flinger = NULL;
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		ret = rk_flinger_free_buffer(flg, &flg->source_buffer[i]);
+		if (ret)
+			DBG("wzqtest:%s: %d", __func__, __LINE__);
+	}
+	for (i = 0; i < NUM_TARGET_BUFFERS; i++) {
+		ret = rk_flinger_free_buffer(flg, &flg->target_buffer[i]);
+		if (ret)
+			DBG("wzqtest:%s: %d", __func__, __LINE__);
+	}
+	rk_flinger_desrtoy_ion_client(flg);
+	kfree(flg);
+#endif
+	DBG("yuyz test %s finish\n", __func__);
+	return 0;
+}
+
+static int rk_flinger_format_hal_to_rga(int format)
+{
+	int rga_format = -1;
+
+	switch (format) {
+	case HAL_PIXEL_FORMAT_RGB_565:
+		rga_format = RK_FORMAT_RGB_565;
+		break;
+	case HAL_PIXEL_FORMAT_RGB_888:
+		rga_format =  RK_FORMAT_RGB_888;
+		break;
+	case HAL_PIXEL_FORMAT_RGBA_8888:
+		rga_format =  RK_FORMAT_RGBA_8888;
+		break;
+	case HAL_PIXEL_FORMAT_RGBX_8888:
+		rga_format =  RK_FORMAT_RGBX_8888;
+		break;
+	case HAL_PIXEL_FORMAT_BGRA_8888:
+		rga_format =  RK_FORMAT_BGRA_8888;
+		break;
+	case HAL_PIXEL_FORMAT_YCrCb_NV12:
+		rga_format =  RK_FORMAT_YCbCr_420_SP;
+		break;
+	case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+		rga_format =  RK_FORMAT_YCbCr_422_SP;
+		break;
+	default:
+		break;
+	}
+
+	return rga_format;
+}
+
+static int rk_flinger_set_rect(struct rect *rect, int x, size_t y,
+			       int w, int h, int s, int f)
+{
+	if (!rect)
+		return -EINVAL;
+
+	rect->x = x;
+	rect->y = y;
+	rect->w = w;
+	rect->h = h;
+	rect->s = s;
+	rect->f = f;
+
+	return 0;
+}
+
+static int
+rk_flinger_set_buffer_rotation(struct graphic_buffer *buffer, int r)
+{
+	if (!buffer)
+		return -EINVAL;
+
+	buffer->rotation = r;
+	return buffer->rotation;
+}
+
+static int
+rk_flinger_cacultae_dst_rect_by_rotation(struct graphic_buffer *buffer)
+{
+	struct rect *src_rect, *dst_rect;
+
+	if (!buffer)
+		return -EINVAL;
+
+	src_rect = &buffer->src;
+	dst_rect = &buffer->dst;
+
+	switch (buffer->rotation) {
+	case RGA_TRANSFORM_ROT_90:
+	case RGA_TRANSFORM_ROT_270:
+		dst_rect->x = src_rect->x;
+		dst_rect->y = src_rect->y;
+		dst_rect->h = src_rect->w;
+		dst_rect->w = src_rect->h;
+		dst_rect->s = src_rect->h;
+		break;
+	case RGA_TRANSFORM_ROT_0:
+	case RGA_TRANSFORM_ROT_180:
+	case RGA_TRANSFORM_FLIP_H:
+	case RGA_TRANSFORM_FLIP_V:
+	default:
+		dst_rect->x = src_rect->x;
+		dst_rect->y = src_rect->y;
+		dst_rect->w = src_rect->w;
+		dst_rect->h = src_rect->h;
+		dst_rect->s = src_rect->s;
+		break;
+	}
+	return 0;
+}
+
+static int rk_flinger_fill_buffer_rects(struct graphic_buffer *buffer,
+					struct rect *src_rect,
+					struct rect *dst_rect)
+{
+	if (!buffer)
+		return -EINVAL;
+
+	if (src_rect)
+		memcpy(&buffer->src, src_rect, sizeof(struct rect));
+	if (dst_rect)
+		memcpy(&buffer->dst, dst_rect, sizeof(struct rect));
+	return 0;
+}
+
+static void field_copy(char *dst_buffer, char *src_buffer, int even_field,
+		       int src_width, int src_height, int src_yuv_stride)
+{
+	char *dst_tmp;
+	char *src_tmp;
+	int vir_ystride = src_width * 2;
+	int vir_uvstride = src_yuv_stride * 2;
+	int h;
+
+	even_field = even_field % 2;
+
+	/*copy y*/
+	dst_tmp = dst_buffer + even_field * src_width;
+	src_tmp = src_buffer;
+	for (h = 0; h < src_height; h++) {
+		memcpy(dst_tmp, src_tmp, src_width);
+		dst_tmp += vir_ystride;
+		src_tmp += src_width;
+	}
+	/*copy uv*/
+	dst_tmp = dst_buffer + src_width * src_height * 2 +
+		even_field * src_yuv_stride;
+	src_tmp = src_buffer + src_width * src_height;
+	for (h = 0; h < src_height; h++) {
+		memcpy(dst_tmp, src_tmp, src_width);
+		dst_tmp += vir_uvstride;
+		src_tmp += src_yuv_stride;
+	}
+}
+
+static int rk_flinger_dump_rga_req(struct rga_req rga_request)
+{
+	return 0;
+}
+
+static int rk_flinger_rga_composite(struct flinger *flinger,
+				    struct graphic_buffer *src_buffer,
+				    struct graphic_buffer *dst_buffer,
+				    int even_field)
+{
+	struct rga_req rga_request;
+	unsigned long src_phy, dst_phy;
+	int sx, sy, sw, sh, ss, sf;
+	int dx, dy, dw, dh, ds, df;
+	int orientation;
+	int ret;
+	int src_fd, dst_fd;
+
+	src_fd = rk_flinger_get_buffer_dma_fd(flinger, src_buffer);
+	dst_fd = rk_flinger_get_buffer_dma_fd(flinger, dst_buffer);
+
+	memset(&rga_request, 0, sizeof(rga_request));
+
+	if (!src_buffer || !dst_buffer)
+		return -EINVAL;
+
+	orientation = RGA_TRANSFORM_ROT_0;/*src_buffer->rotation*/
+
+	sx = src_buffer->src.x;
+	sy = src_buffer->src.y;
+	sw = src_buffer->src.w;
+	ss = src_buffer->src.s;
+	sh = src_buffer->src.h;
+	sf = rk_flinger_format_hal_to_rga(src_buffer->src.f);
+
+	dx = src_buffer->src.x;
+	dy = src_buffer->src.y;
+	dw = src_buffer->src.w;
+	ds = src_buffer->src.s * 2;
+	dh = src_buffer->src.h;
+	df = rk_flinger_format_hal_to_rga(src_buffer->src.f);
+
+	src_phy = src_buffer->phy_addr + src_buffer->offset;
+	dst_phy = dst_buffer->phy_addr + dst_buffer->offset;
+
+	rga_request.rotate_mode = 0;
+	rga_request.sina = 0;
+	rga_request.cosa = 0;
+	rga_request.dst.vir_w = ds;
+	rga_request.dst.vir_h = dh;
+	rga_request.dst.act_w = dw;
+	rga_request.dst.act_h = dh;
+	rga_request.dst.x_offset = even_field ? dw : 0;
+	rga_request.dst.y_offset = 0;
+
+	rga_request.src.yrgb_addr = src_fd;
+#if defined(__arm64__) || defined(__aarch64__)
+	rga_request.src.uv_addr = (unsigned long)src_phy;
+	rga_request.src.v_addr = (unsigned long)src_phy + ss * sh;
+#else
+	rga_request.src.uv_addr = (unsigned int)0;
+	rga_request.src.v_addr = (unsigned int)0;
+#endif
+
+	rga_request.dst.yrgb_addr = -1;/*dst_fd;*/
+#if defined(__arm64__) || defined(__aarch64__)
+	rga_request.dst.uv_addr = (unsigned long)dst_phy;
+	rga_request.dst.v_addr = (unsigned long)dst_phy + ds * sh;
+#else
+	rga_request.dst.uv_addr = (unsigned int)0;
+	rga_request.dst.v_addr = (unsigned int)0;
+#endif
+
+	rga_request.src.vir_w = ss;
+	rga_request.src.vir_h = sh;
+	rga_request.src.format = sf;
+	rga_request.src.act_w = sw;
+	rga_request.src.act_h = sh;
+	rga_request.src.x_offset = 0;
+	rga_request.src.y_offset = 0;
+
+	rga_request.dst.format = df;
+
+	rga_request.clip.xmin = 0;
+	rga_request.clip.xmax = dw - 1;
+	rga_request.clip.ymin = 0;
+	rga_request.clip.ymax = dh - 1;
+	rga_request.scale_mode = 0;
+
+	/* rga_request.mmu_info.mmu_en = 1; */
+	/* rga_request.mmu_info.mmu_flag = ((2 & 0x3) << 4) |
+		 1 | (1 <<31 | 1 << 8 | 1<<10); */
+
+	rk_flinger_dump_rga_req(rga_request);
+
+	ret = rga_ioctl_kernel(&rga_request);
+	if (ret)
+		DBG("RGA_BLIT_SYNC faile(%d)\n", ret);
+
+	return 0;
+}
+
+/*composite 2 field to 1 frame*/
+static int rk_flinger_soft_composite(struct flinger *flinger,
+				     struct graphic_buffer *src_buffer,
+				     struct graphic_buffer *dst_buffer)
+{
+	#define USE_RGA_COMPOSITE (1)
+	int even_field;
+	struct flinger *flg = flinger;
+	int src_width;
+	int src_height;
+	int src_yuv_stride;
+
+	src_width = src_buffer->src.w;
+	src_height = src_buffer->src.h;
+	if (CIF_OUTPUT_FORMAT_422 == flinger->v_cfg.output_format)
+		src_yuv_stride = src_width;
+	else
+		src_yuv_stride = src_width / 2;
+	even_field = flg->cvbs_field_count % 2;
+
+	if (USE_RGA_COMPOSITE) {
+		rk_flinger_rga_composite(flg, src_buffer, dst_buffer,
+					 even_field);
+	} else {
+		field_copy(dst_buffer->vir_addr, src_buffer->vir_addr,
+			   even_field, src_width, src_height,
+			   src_yuv_stride);
+		if (flg->cvbs_field_count == 0)
+			field_copy(dst_buffer->vir_addr, src_buffer->vir_addr,
+				   !even_field, src_width, src_height,
+				   src_yuv_stride);
+	}
+	src_buffer->state = FREE;
+	flg->cvbs_field_count++;
+
+	/*  copy param to dst buffer */
+	dst_buffer->format = src_buffer->format;
+	dst_buffer->rotation = src_buffer->rotation;
+	memcpy(&dst_buffer->src, &src_buffer->src, sizeof(struct rect));
+	memcpy(&dst_buffer->dst, &src_buffer->dst, sizeof(struct rect));
+	dst_buffer->src.h *= 2;
+	rk_flinger_cacultae_dst_rect_by_rotation(dst_buffer);
+	return 0;
+}
+
+static int rk_flinger_iep_deinterlace(struct flinger *flinger,
+				      struct graphic_buffer *src_buffer,
+				      struct graphic_buffer *dst_buffer)
+{
+	struct IEP_MSG *msg;
+	int w;
+	int h;
+	int src_fd, dst_fd;
+	int iep_format;
+	struct graphic_buffer *com_buffer = src_buffer;
+
+	if (flinger->v_cfg.input_format == CIF_INPUT_FORMAT_PAL_SW_COMPOSITE ||
+	    flinger->v_cfg.input_format == CIF_INPUT_FORMAT_NTSC_SW_COMPOSITE) {
+		com_buffer = &flinger->cvbs_buffer;
+		rk_flinger_soft_composite(flinger, src_buffer, com_buffer);
+		src_buffer->state = FREE;
+		src_buffer = com_buffer;
+	}
+
+	if (CIF_OUTPUT_FORMAT_422 == flinger->v_cfg.output_format)
+		iep_format = IEP_FORMAT_YCbCr_422_SP;
+	else
+		iep_format = IEP_FORMAT_YCbCr_420_SP;
+
+    msg = (struct IEP_MSG *)kzalloc(sizeof(struct IEP_MSG),
+      GFP_KERNEL);
+    if (!msg)
+        return -ENOMEM;
+
+	memset(msg, 0, sizeof(struct IEP_MSG));
+
+	w = src_buffer->src.w;
+	h = src_buffer->src.h;
+
+	src_fd = rk_flinger_get_buffer_dma_fd(flinger, src_buffer);
+	dst_fd = rk_flinger_get_buffer_dma_fd(flinger, dst_buffer);
+
+	msg->src.act_w = w;
+	msg->src.act_h = h;
+	msg->src.x_off = 0;
+	msg->src.y_off = 0;
+	msg->src.vir_w = w;
+	msg->src.vir_h = h;
+	msg->src.format = iep_format;
+	msg->src.mem_addr = src_fd;
+	msg->src.uv_addr  = src_fd | (w * h << 10);
+	msg->src.v_addr = 0;
+
+	msg->dst.act_w = w;
+	msg->dst.act_h = h;
+	msg->dst.x_off = 0;
+	msg->dst.y_off = 0;
+	msg->dst.vir_w = w;
+	msg->dst.vir_h = h;
+	msg->dst.format = iep_format;
+	msg->dst.mem_addr = dst_fd;
+	msg->dst.uv_addr = dst_fd | (w * h << 10);
+	msg->dst.v_addr = 0;
+
+	msg->dein_high_fre_en = 1;
+	msg->dein_mode = IEP_DEINTERLACE_MODE_I2O1;
+	msg->field_order = FIELD_ORDER_BOTTOM_FIRST;
+	msg->dein_high_fre_fct = 50;
+	msg->dein_ei_mode = 1;
+	msg->dein_ei_smooth = 1;
+	msg->dein_ei_sel = 0;
+	msg->dein_ei_radius = 2;
+
+	iep_process_sync(msg);
+	kfree(msg);
+
+	/*  copy param to dst buffer */
+	dst_buffer->format = src_buffer->format;
+	dst_buffer->rotation = src_buffer->rotation;
+	memcpy(&dst_buffer->src, &src_buffer->src, sizeof(struct rect));
+	memcpy(&dst_buffer->dst, &src_buffer->dst, sizeof(struct rect));
+
+	src_buffer->state = FREE;
+	return 0;
+}
+
+static int rk_flinger_rga_blit(struct flinger *flinger,
+			       struct graphic_buffer *src_buffer,
+			       struct graphic_buffer *dst_buffer)
+{
+	struct rga_req rga_request;
+	unsigned long src_phy;
+	int sx, sy, sw, sh, ss, sf;
+	int dx, dy, dw, dh, ds, df;
+	int orientation;
+	int ret;
+	int src_fd, dst_fd;
+
+	src_fd = rk_flinger_get_buffer_dma_fd(flinger, src_buffer);
+	dst_fd = rk_flinger_get_buffer_dma_fd(flinger, dst_buffer);
+
+	memset(&rga_request, 0, sizeof(rga_request));
+
+	if (!src_buffer || !dst_buffer)
+		return -EINVAL;
+
+	orientation = src_buffer->rotation;
+
+	sx = src_buffer->src.x;
+	sy = src_buffer->src.y;
+	sw = src_buffer->src.w;
+	ss = src_buffer->src.s;
+	sh = src_buffer->src.h;
+	sf = rk_flinger_format_hal_to_rga(src_buffer->src.f);
+
+	dx = src_buffer->dst.x;
+	dy = src_buffer->dst.y;
+	dw = src_buffer->dst.w;
+	ds = src_buffer->dst.s;
+	dh = src_buffer->dst.h;
+	df = rk_flinger_format_hal_to_rga(src_buffer->dst.f);
+
+	src_phy = src_buffer->phy_addr + src_buffer->offset;
+
+	if (src_buffer->offset) {
+		sh += src_buffer->offset / src_buffer->len * sh;
+		sx = src_buffer->offset / src_buffer->len * sh;
+		src_fd = 0;
+	}
+
+	switch (orientation) {
+	case RGA_TRANSFORM_ROT_0:
+		rga_request.rotate_mode = 0;
+		rga_request.sina = 0;
+		rga_request.cosa = 0;
+		rga_request.dst.vir_w = ds;
+		rga_request.dst.vir_h = dh;
+		rga_request.dst.act_w = dw;
+		rga_request.dst.act_h = dh;
+		rga_request.dst.x_offset = 0;
+		rga_request.dst.y_offset = 0;
+		break;
+	case RGA_TRANSFORM_FLIP_H:/*x mirror*/
+		rga_request.rotate_mode = 2;
+		rga_request.dst.vir_w = ds;
+		rga_request.dst.vir_h = dh;
+		rga_request.dst.act_w = dw;
+		rga_request.dst.act_h = dh;
+		rga_request.dst.x_offset = 0;
+		rga_request.dst.y_offset = 0;
+		break;
+	case RGA_TRANSFORM_FLIP_V:/*y mirror*/
+		rga_request.rotate_mode = 3;
+		rga_request.dst.vir_w = ds;
+		rga_request.dst.vir_h = dh;
+		rga_request.dst.act_w = dw;
+		rga_request.dst.act_h = dh;
+		rga_request.dst.x_offset = 0;
+		rga_request.dst.y_offset = 0;
+		break;
+	case RGA_TRANSFORM_ROT_90:
+		rga_request.rotate_mode = 1;
+		rga_request.sina = 65536;
+		rga_request.cosa = 0;
+		rga_request.dst.vir_w = ds;
+		rga_request.dst.vir_h = dh;
+		rga_request.dst.act_w = dh;
+		rga_request.dst.act_h = dw;
+		rga_request.dst.x_offset = dw - 1;
+		rga_request.dst.y_offset = 0;
+		break;
+	case RGA_TRANSFORM_ROT_180:
+		rga_request.rotate_mode = 1;
+		rga_request.sina = 0;
+		rga_request.cosa = -65536;
+		rga_request.dst.vir_w = ds;
+		rga_request.dst.vir_h = dh;
+		rga_request.dst.act_w = dw;
+		rga_request.dst.act_h = dh;
+		rga_request.dst.x_offset = dw - 1;
+		rga_request.dst.y_offset = dh - 1;
+		break;
+	case RGA_TRANSFORM_ROT_270:
+		rga_request.rotate_mode = 1;
+		rga_request.sina = -65536;
+		rga_request.cosa = 0;
+		rga_request.dst.vir_w = ds;
+		rga_request.dst.vir_h = dh;
+		rga_request.dst.act_w = dh;
+		rga_request.dst.act_h = dw;
+		rga_request.dst.x_offset = 0;
+		rga_request.dst.y_offset = dh - 1;
+		break;
+	default:
+		rga_request.rotate_mode = 0;
+		rga_request.sina = 0;
+		rga_request.cosa = 0;
+		rga_request.dst.vir_w = ds;
+		rga_request.dst.vir_h = dh;
+		rga_request.dst.act_w = dw;
+		rga_request.dst.act_h = dh;
+		rga_request.dst.x_offset = 0;
+		rga_request.dst.y_offset = 0;
+		break;
+	}
+
+#ifdef RK312X_RGA
+    if (orientation == RGA_TRANSFORM_ROT_90 ||
+        orientation == RGA_TRANSFORM_ROT_180 ||
+        orientation == RGA_TRANSFORM_ROT_270) {
+        df = RK_FORMAT_RGBX_8888;
+    }
+#endif
+
+	rga_request.src.yrgb_addr = src_fd;
+#if defined(__arm64__) || defined(__aarch64__)
+	rga_request.src.uv_addr = (unsigned long)src_phy;
+	rga_request.src.v_addr = (unsigned long)src_phy + ss * sh;
+#else
+	rga_request.src.uv_addr = (unsigned int)0;
+	rga_request.src.v_addr = (unsigned int)0;
+#endif
+
+	rga_request.dst.yrgb_addr = dst_fd;
+#if defined(__arm64__) || defined(__aarch64__)
+	rga_request.dst.uv_addr = (unsigned long)0;
+	rga_request.dst.v_addr = (unsigned long)0;
+#else
+	rga_request.dst.uv_addr = (unsigned int)0;
+	rga_request.dst.v_addr = (unsigned int)0;
+#endif
+
+	rga_request.src.vir_w = ss;
+	rga_request.src.vir_h = sh;
+	rga_request.src.format = sf;
+	rga_request.src.act_w = sw;
+	rga_request.src.act_h = sh;
+	rga_request.src.x_offset = 0;
+	rga_request.src.y_offset = 0;
+
+	rga_request.dst.format = df;
+
+	rga_request.clip.xmin = 0;
+	rga_request.clip.xmax = dw - 1;
+	rga_request.clip.ymin = 0;
+	rga_request.clip.ymax = dh - 1;
+	rga_request.scale_mode = 0;
+
+	/* rga_request.mmu_info.mmu_en = 1; */
+	/* rga_request.mmu_info.mmu_flag = ((2 & 0x3) << 4) |
+		 1 | (1 <<31 | 1 << 8 | 1<<10); */
+
+	rk_flinger_dump_rga_req(rga_request);
+
+	ret = rga_ioctl_kernel(&rga_request);
+	if (ret)
+		DBG("RGA_BLIT_SYNC faile(%d)\n", ret);
+
+	rk_flinger_dump_rga_req(rga_request);
+
+	return 0;
+}
+
+static int rk_flinger_rga_render(struct flinger *flinger,
+				 struct graphic_buffer *src_buffer,
+				 struct graphic_buffer *dst_buffer)
+{
+	int timeout = 508;
+
+	if (!flinger || !src_buffer || !dst_buffer)
+		return -EINVAL;
+
+	if (dst_buffer && dst_buffer->rel_fence) {
+		if (0)
+			sync_fence_wait(dst_buffer->rel_fence, timeout);
+		sync_fence_put(dst_buffer->rel_fence);
+		dst_buffer->rel_fence = NULL;
+	}
+	rk_flinger_rga_blit(flinger, src_buffer, dst_buffer);
+	rk_flinger_fill_buffer_rects(dst_buffer, &src_buffer->dst,
+				     &src_buffer->dst);
+
+#ifdef RK312X_RGA
+/*YCrCb422 after rotate 90 / 270 degree, become YCrCb444*/
+    if (src_buffer->rotation == RGA_TRANSFORM_ROT_90 ||
+        src_buffer->rotation == RGA_TRANSFORM_ROT_180 ||
+        src_buffer->rotation == RGA_TRANSFORM_ROT_270)
+        dst_buffer->src.f = RK_FORMAT_RGBX_8888;
+#endif
+	return 0;
+}
+
+static int rk_flinger_vop_show_logo(struct flinger *flinger,
+				    struct rk_fb_car_par *par)
+{
+	struct rk_fb_win_cfg_data fb_info;
+	int i, j, fence_fd = -1;
+	struct sync_fence *rel_fence = NULL;
+
+	memset(&fb_info, 0, sizeof(struct rk_fb_win_cfg_data));
+	fb_info.ret_fence_fd = -1;
+	for (i = 0; i < RK_MAX_BUF_NUM; i++)
+		fb_info.rel_fence_fd[i] = -1;
+
+	fb_info.wait_fs = 0;
+
+	fb_info.win_par[0].win_id = 0;
+	fb_info.win_par[0].z_order = 0;
+	fb_info.win_par[0].area_par[0].ion_fd = -1;
+	fb_info.win_par[0].area_par[0].phy_addr = par->direct_show.rgb_mst;
+	fb_info.win_par[0].area_par[0].acq_fence_fd = -1;
+
+	fb_info.win_par[0].area_par[0].x_offset = 0;
+	fb_info.win_par[0].area_par[0].y_offset = 0;
+	fb_info.win_par[0].area_par[0].xact = par->direct_show.xact;
+	fb_info.win_par[0].area_par[0].yact = par->direct_show.yact;
+	fb_info.win_par[0].area_par[0].xvir = par->direct_show.xact;
+	fb_info.win_par[0].area_par[0].yvir = par->direct_show.yact;
+
+	fb_info.win_par[0].area_par[0].
+		xpos = (par->screen_width - par->direct_show.xact) >> 1;
+	fb_info.win_par[0].area_par[0].
+		ypos = (par->screen_height - par->direct_show.yact) >> 1;
+	fb_info.win_par[0].area_par[0].xsize = par->direct_show.xact;
+	fb_info.win_par[0].area_par[0].ysize = par->direct_show.yact;
+
+	if (par->direct_show.format == RGB565)
+		fb_info.win_par[0].area_par[0].
+			data_format = HAL_PIXEL_FORMAT_RGB_565;
+	else if (par->direct_show.format == RGB888)
+		fb_info.win_par[0].area_par[0].
+			data_format = HAL_PIXEL_FORMAT_RGB_888;
+	else
+		return -1;
+
+	do {
+		i = 0;
+		j = 0;
+
+		/*DBG("wzqtest[%d]win[%d], area[%d], z_win[%d,%d],
+				[%d,%d,%d,%d]=>[%d,%d,%d,%d], w_h_f[%d,%d,%d],
+				fd=%d, addr=%x\n",
+				current->pid,
+				i, j,
+				fb_info.win_par[i].z_order,
+				fb_info.win_par[i].win_id,
+				fb_info.win_par[i].area_par[j].x_offset,
+				fb_info.win_par[i].area_par[j].y_offset,
+				fb_info.win_par[i].area_par[j].xact,
+				fb_info.win_par[i].area_par[j].yact,
+				fb_info.win_par[i].area_par[j].xpos,
+				fb_info.win_par[i].area_par[j].ypos,
+				fb_info.win_par[i].area_par[j].xsize,
+				fb_info.win_par[i].area_par[j].ysize,
+				fb_info.win_par[i].area_par[j].xvir,
+				fb_info.win_par[i].area_par[j].yvir,
+				fb_info.win_par[i].area_par[j].data_format,
+				fb_info.win_par[i].area_par[j].ion_fd,
+				fb_info.win_par[i].area_par[j].phy_addr);*/
+
+		rk_set_dsp(RK_FBIOSET_CAR_CONFIG_DONE,
+			   (unsigned long)(&fb_info));
+
+		if (fb_info.ret_fence_fd > -1) {
+			fence_fd = fb_info.ret_fence_fd;
+			if (fence_fd > -1)
+				rel_fence = sync_fence_fdget(fence_fd);
+			if (rel_fence) {
+				sync_fence_put(rel_fence);
+				rel_fence = NULL;
+				__close_fd(current->files, fence_fd);
+				fence_fd = -1;
+			}
+		}
+
+		for (i = 0; i < RK_MAX_BUF_NUM; i++) {
+			fence_fd = fb_info.rel_fence_fd[i];
+			if (fence_fd > -1)
+				rel_fence = sync_fence_fdget(fence_fd);
+			if (rel_fence) {
+				sync_fence_put(rel_fence);
+				rel_fence = NULL;
+				__close_fd(current->files, fence_fd);
+				fence_fd = -1;
+			}
+		}
+	} while (0);
+
+	return 0;
+}
+
+static int rk_flinger_vop_show(struct flinger *flinger,
+			       struct graphic_buffer *buffer)
+{
+	struct rk_fb_win_cfg_data fb_info;
+	unsigned long vir_addr;
+	int i, j, fence_fd, ion_hnd_fd = -1;
+	struct sync_fence *rel_fence = NULL;
+	struct rk_fb_car_par *par = rk_fb_get_car_par();
+	u32 phy_addr = buffer->phy_addr;
+	u32 len;
+
+	if (!flinger || !buffer)
+		return -EINVAL;
+
+	if (buffer->state != ACQUIRE)
+		DBG("buf[%p] not acquired[%d]", buffer, buffer->state);
+  
+#ifdef CONFIG_DRM_ROCKCHIP
+   // if vop iommu enabled
+	if (par->fb_inited && par->iommu_enabled) {
+    	  ion_map_iommu(par->dev,
+			    flinger->ion_client,
+			    buffer->handle,
+			    (unsigned long *)&phy_addr,
+			    (unsigned long *)&len);
+        //DBG("iommu map phy = %x, raw phy = %lx\n", phy_addr, buffer->phy_addr);
+   }
+#endif
+	ion_hnd_fd = rk_flinger_get_buffer_dma_fd(flinger, buffer);
+	if (ion_hnd_fd < 0)
+		return -EINVAL;
+
+	if (0 == par->car_reversing)
+		return 0;
+
+	memset(&fb_info, 0, sizeof(struct rk_fb_win_cfg_data));
+	fb_info.ret_fence_fd = -1;
+	for (i = 0; i < RK_MAX_BUF_NUM; i++)
+		fb_info.rel_fence_fd[i] = -1;
+
+	fb_info.wait_fs = 0;
+
+	fb_info.win_par[0].area_par[0].data_format = buffer->src.f;
+	fb_info.win_par[0].win_id = 0;
+	fb_info.win_par[0].z_order = 0;
+	fb_info.win_par[0].area_par[0].ion_fd = buffer->ion_hnd_fd;
+	fb_info.win_par[0].area_par[0].phy_addr = phy_addr;
+	fb_info.win_par[0].area_par[0].acq_fence_fd = -1;
+
+	fb_info.win_par[0].area_par[0].x_offset = buffer->src.x;
+	fb_info.win_par[0].area_par[0].y_offset = buffer->src.y;
+	fb_info.win_par[0].area_par[0].xact = buffer->src.w;
+	fb_info.win_par[0].area_par[0].yact = buffer->src.h;
+	fb_info.win_par[0].area_par[0].xvir = buffer->src.s;
+	fb_info.win_par[0].area_par[0].yvir = buffer->src.h;
+
+	fb_info.win_par[0].area_par[0].xpos = buffer->dst.x;
+	fb_info.win_par[0].area_par[0].ypos = buffer->dst.y;
+	fb_info.win_par[0].area_par[0].xsize = par->screen_width;
+	fb_info.win_par[0].area_par[0].ysize = par->screen_height;
+	fb_info.win_par[0].area_par[0].data_format = buffer->src.f;
+
+	vir_addr = (unsigned long)(&fb_info);
+	do {
+		i = 0;
+		j = 0;
+
+		flinger->debug_vop_count++;
+
+        if (0) {
+            static struct file *filep;
+            static loff_t pos;
+            static const int record_frame_count = 200;
+            static int frame_count;
+            if (++frame_count < record_frame_count) {
+                int frame_len = buffer->src.w * buffer->src.h * 4 / 2;
+                int ret;
+                char path[32] = {0};
+                mm_segment_t fs;
+
+                if (!filep) {
+                    sprintf(path, "/data/test.dat");
+                    filep = filp_open(path, O_CREAT | O_RDWR, 0644);
+                    if (IS_ERR(filep))
+                        return 0;
+                }
+                fs = get_fs();
+                set_fs(KERNEL_DS);
+                ret = vfs_write(filep, buffer->vir_addr, frame_len, &pos);
+                set_fs(fs);
+            } else if (filep) {
+                filp_close(filep, 0);
+                filep = NULL;
+            }
+        }
+
+		rk_set_dsp(RK_FBIOSET_CAR_CONFIG_DONE, vir_addr);
+
+		/* DBG("wzqtest:%s,%d\n", __func__, __LINE__); */
+		if (fb_info.ret_fence_fd > -1) {
+			fence_fd = fb_info.ret_fence_fd;
+			if (fence_fd > -1)
+				rel_fence = sync_fence_fdget(fence_fd);
+			if (rel_fence) {
+				sync_fence_put(rel_fence);
+				rel_fence = NULL;
+				__close_fd(current->files, fence_fd);
+				fence_fd = -1;
+			}
+		}
+
+		for (i = 0; i < RK_MAX_BUF_NUM; i++) {
+			fence_fd = fb_info.rel_fence_fd[i];
+			if (fence_fd > -1)
+				rel_fence = sync_fence_fdget(fence_fd);
+			if (rel_fence) {
+				sync_fence_put(rel_fence);
+				rel_fence = NULL;
+				__close_fd(current->files, fence_fd);
+				fence_fd = -1;
+			}
+		}
+	} while (0);
+
+	return 0;
+}
+
+static void rk_flinger_first_done(struct work_struct *work)
+{
+	struct graphic_buffer *buffer;
+	struct flinger *flg = flinger;
+	int i, fd;
+
+	if (!flg)
+		return;
+
+	fd = get_unused_fd();
+
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		if (flg->source_buffer[i].state == FREE) {
+			buffer = &(flg->source_buffer[i]);
+			rk_flinger_set_rect(&buffer->src,
+					    FORCE_XOFFSET, FORCE_YOFFSET,
+					    FORCE_WIDTH, FORCE_HEIGHT,
+					    FORCE_STRIDE, FORCE_FORMAT);
+			rk_flinger_set_buffer_rotation(buffer, FORCE_ROTATION);
+			rk_flinger_cacultae_dst_rect_by_rotation(buffer);
+			buffer->dst.f = buffer->src.f;
+		}
+	}
+}
+
+static void rk_flinger_render_show(struct work_struct *w)
+{
+	struct graphic_buffer *src_buffer, *dst_buffer, *iep_buffer, *buffer;
+	/* struct queue_buffer *cur = NULL, *next = NULL; */
+	struct flinger *flg = flinger;
+	int i, found = 0;
+	static int count = -1;
+	static int last_src_index = -1;
+
+	src_buffer = NULL;
+	dst_buffer = NULL;
+	flg->source_index = 0;
+
+	do {
+try_again:
+		wait_event_interruptible_timeout(flg->worker_wait,
+						 atomic_read(&flg->worker_cond_atomic),
+						 msecs_to_jiffies(1000000));
+		if (0 == atomic_read(&flg->worker_running_atomic)) {
+			DBG("%s loop exit\n", __func__);
+			break;
+		}
+		if (0 >= atomic_read(&flg->worker_cond_atomic)) {
+			/*printk("waiting 'worker_cond_atomic' timed out.");*/
+			goto try_again;
+		}
+		atomic_dec(&flg->worker_cond_atomic);
+
+#ifdef FIX_SOURCE_BUFFER
+		found = atomic_read(&flg->souce_frame_atomic);
+		if (found < 0 || found > 1)
+			goto try_again;
+		src_buffer = &flg->source_buffer[found];
+		last_src_index = found;
+#else
+		/*  1. find src buffer */
+		src_buffer = NULL;
+		found = last_src_index + 1;
+		for (i = 0; i < NUM_SOURCE_BUFFERS; i++, found++) {
+			found = found % NUM_SOURCE_BUFFERS;
+			if (flg->source_buffer[found].state == QUEUE) {
+				src_buffer = &flg->source_buffer[found];
+				last_src_index = found;
+				break;
+			}
+		}
+#endif
+
+		if (!src_buffer) {
+			msleep(3);
+			DBG("[%s:%d] error, no buffer\n", __func__, __LINE__);
+			goto try_again;
+		}
+
+		//DBG("src buffer %lx\n",src_buffer->phy_addr);
+		count++;
+		src_buffer->state = ACQUIRE;
+
+		if (!iep_device_ready()) {
+			src_buffer->state = FREE;
+			DBG("%s iep not ready, continue\n", __func__);
+			continue;
+		}
+		/*  2. find dst buffer */
+		dst_buffer = NULL;
+		iep_buffer = NULL;
+
+		/*get iep, rga, vop buffer*/
+		if (src_buffer->rotation != 0) {
+			if (flg->v_cfg.input_format == CIF_INPUT_FORMAT_PAL ||
+			    flg->v_cfg.input_format == CIF_INPUT_FORMAT_NTSC ||
+			    flg->v_cfg.input_format ==
+			    CIF_INPUT_FORMAT_PAL_SW_COMPOSITE ||
+				flg->v_cfg.input_format ==
+				CIF_INPUT_FORMAT_NTSC_SW_COMPOSITE) {
+				iep_buffer = &(flg->target_buffer
+					       [NUM_TARGET_BUFFERS - 1]);
+			}
+			dst_buffer = &(flg->target_buffer
+				       [count % (NUM_TARGET_BUFFERS - 1)]);
+			dst_buffer->state = ACQUIRE;
+		} else if (flg->v_cfg.input_format == CIF_INPUT_FORMAT_PAL ||
+			   flg->v_cfg.input_format == CIF_INPUT_FORMAT_NTSC ||
+			   flg->v_cfg.input_format ==
+			   CIF_INPUT_FORMAT_PAL_SW_COMPOSITE ||
+			   flg->v_cfg.input_format ==
+			   CIF_INPUT_FORMAT_NTSC_SW_COMPOSITE) {
+			iep_buffer = &(flg->target_buffer
+				       [count % NUM_TARGET_BUFFERS]);
+			iep_buffer->state = ACQUIRE;
+		}
+
+		//eip_buffer = NULL;
+
+		/*do deinterlace & rotation & display*/
+		if (src_buffer->rotation != 0) {
+			if (iep_buffer) {
+				rk_flinger_iep_deinterlace(flg, src_buffer,
+							   iep_buffer);
+				rk_flinger_rga_render(flg,
+						      iep_buffer, dst_buffer);
+			} else {
+				rk_flinger_rga_render(flg,
+						      src_buffer, dst_buffer);
+				src_buffer->state = FREE;
+			}
+			rk_flinger_vop_show(flg, dst_buffer);
+			for (i = 0; i < NUM_TARGET_BUFFERS; i++) {
+				buffer = &(flinger->target_buffer[i]);
+				if (buffer->state == DISPLAY)
+					buffer->state = FREE;
+			}
+			dst_buffer->state = DISPLAY;
+		} else {
+			if (iep_buffer) {
+				rk_flinger_iep_deinterlace(flg, src_buffer,
+							   iep_buffer);
+				rk_flinger_vop_show(flg, iep_buffer);
+			} else {
+				rk_flinger_vop_show(flg, src_buffer);
+			}
+			src_buffer->state = FREE;
+		}
+	} while (1);
+}
+
+static int rk_flinger_queue_work(struct flinger *flinger,
+				 struct graphic_buffer *src_buffer)
+{
+	DBG("wzqtest:%s,%d\n", __func__, __LINE__);
+	if (!flinger)
+		return -ENODEV;
+
+	if (!src_buffer) {
+		if (flinger->render_workqueue) {
+			INIT_WORK(&flinger->init_work, rk_flinger_first_done);
+			queue_work(flinger->render_workqueue,
+				   &flinger->init_work);
+		}
+	}
+
+	if (flinger->render_workqueue) {
+		INIT_WORK(&flinger->render_work, rk_flinger_render_show);
+		queue_work(flinger->render_workqueue, &flinger->render_work);
+	}
+	return 0;
+}
+
+static struct graphic_buffer *
+rk_flinger_lookup_buffer_by_phy_addr(unsigned long phy_addr)
+{
+	struct graphic_buffer *buffer = NULL;
+	struct flinger *flg = flinger;
+	int i;
+
+	/*DBG("%s:phy_addr=%lx\n", __func__, phy_addr);*/
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		if (flg->source_buffer[i].state == DEQUEUE) {
+			buffer = &(flg->source_buffer[i]);
+			if (buffer && buffer->offset +
+			    buffer->phy_addr == phy_addr) {
+				buffer->state = QUEUE;
+				break;
+			}
+		}
+	}
+	if (i < NUM_SOURCE_BUFFERS)
+		return buffer;
+	else
+		return NULL;
+}
+
+static bool vehicle_rotation_param_check(struct vehicle_cfg *v_cfg)
+{
+	switch (v_cfg->rotate_mirror) {
+	case RGA_TRANSFORM_ROT_90:
+	case RGA_TRANSFORM_ROT_270:
+	case RGA_TRANSFORM_ROT_0:
+	case RGA_TRANSFORM_ROT_180:
+	case RGA_TRANSFORM_FLIP_H:
+	case RGA_TRANSFORM_FLIP_V:
+		return true;
+	default:
+		DBG("invalid rotate-mirror param %d\n", v_cfg->rotate_mirror);
+		v_cfg->rotate_mirror = 0;
+		return false;
+	}
+}
+int vehicle_flinger_reverse_open(struct vehicle_cfg *v_cfg)
+{
+	int i;
+	int width;
+	int height;
+	struct flinger *flg = flinger;
+	struct graphic_buffer *buffer;
+	int hal_format;
+
+	width = v_cfg->width;
+	height = v_cfg->height;
+
+	if (!flinger)
+		return -1;
+
+	DBG("%s\n", __func__);
+
+	vehicle_rotation_param_check(v_cfg);
+
+	if (CIF_OUTPUT_FORMAT_422 == v_cfg->output_format)
+		hal_format = HAL_PIXEL_FORMAT_YCbCr_422_SP;
+	else
+		hal_format = HAL_PIXEL_FORMAT_YCrCb_NV12;
+
+	/*  1. reinit buffer format */
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		buffer = &(flg->source_buffer[i]);
+		rk_flinger_set_rect(&buffer->src,
+				    0, 0, width,
+				    height, width, hal_format);
+		rk_flinger_set_buffer_rotation(buffer, v_cfg->rotate_mirror);
+		rk_flinger_cacultae_dst_rect_by_rotation(buffer);
+		buffer->dst.f = buffer->src.f;
+		buffer->state = FREE;
+	}
+
+	/*2. fill buffer info*/
+	for (i = 0; i < NUM_SOURCE_BUFFERS && i < MAX_BUF_NUM; i++)
+		v_cfg->buf_phy_addr[i] = flinger->source_buffer[i].phy_addr;
+	v_cfg->buf_num = NUM_SOURCE_BUFFERS;
+
+	flg->cvbs_field_count = 0;
+	memcpy(&flg->v_cfg, v_cfg, sizeof(struct vehicle_cfg));
+	rk_set_car_reverse(true);
+  
+	DBG("%s succeed\n", __func__);
+	return 0;
+}
+
+int vehicle_flinger_reverse_close(void)
+{
+	struct flinger *flg = flinger;
+	struct rk_fb_car_par *par;
+
+	DBG("%s\n", __func__);
+
+	rk_set_car_reverse(false);
+	par = rk_fb_get_car_par();
+	if (par->logo_showing)
+		rk_flinger_vop_show_logo(flg, par);
+	return 0;
+}
+/*frame_ready: 0, 1;pingpong buffer of cif*/
+unsigned long vehicle_flinger_request_cif_buffer(int frame_ready)
+{
+#ifdef FIX_SOURCE_BUFFER
+	struct flinger *flg = flinger;
+
+	if (frame_ready < 0 || frame_ready > 1)
+		return 0;
+	return flg->source_buffer[frame_ready].phy_addr;
+#else
+	struct graphic_buffer *src_buffer = NULL;
+	struct flinger *flg = flinger;
+	static int last_src_index = -1;
+	int found;
+	int i;
+
+	src_buffer = NULL;
+	found = last_src_index + 1;
+	for (i = 0; i < NUM_SOURCE_BUFFERS; i++) {
+		found = (found + i) % NUM_SOURCE_BUFFERS;
+		if (flg->source_buffer[found].state == FREE) {
+			src_buffer = &flg->source_buffer[found];
+			last_src_index = found;
+			src_buffer->state = DEQUEUE;
+			break;
+		}
+	}
+
+	if (i < NUM_SOURCE_BUFFERS)
+		return src_buffer->phy_addr;
+	else
+		return 0;
+#endif
+}
+
+void vehicle_flinger_commit_cif_buffer(u32 buf_phy_addr)
+{
+	struct graphic_buffer *buffer = NULL;
+	struct flinger *flg = flinger;
+
+	if (!flg)
+		return;
+
+#ifdef FIX_SOURCE_BUFFER
+	if (buf_phy_addr == flg->source_buffer[0].phy_addr)
+		atomic_set(&flg->souce_frame_atomic, 0);
+	else
+		atomic_set(&flg->souce_frame_atomic, 1);
+	atomic_inc(&flg->worker_cond_atomic);
+	flg->debug_cif_count++;
+	wake_up(&flg->worker_wait);
+	return;
+#endif
+
+	buffer = rk_flinger_lookup_buffer_by_phy_addr(buf_phy_addr);
+	if (buffer) {
+		atomic_inc(&flg->worker_cond_atomic);
+		flg->debug_cif_count++;
+		wake_up(&flg->worker_wait);
+	} else {
+		DBG("%s,%x, no free buffer\n", __func__, buf_phy_addr);
+	}
+}
diff --git a/drivers/video/rockchip/vehicle/vehicle_flinger.h b/drivers/video/rockchip/vehicle/vehicle_flinger.h
new file mode 100755
index 0000000..a61d4c6
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_flinger.h
@@ -0,0 +1,42 @@
+/*
+ * drivers/video/rockchip/flinger/flinger.c
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co.Ltd
+ * Authors:
+ *      Zhiqin Wei <wzq@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "vehicle_cfg.h"
+
+#ifndef _drivers_video_rockchip_flinger_h_
+#define _drivers_video_rockchip_flinger_h_
+
+int vehicle_flinger_init(struct device *dev);
+int vehicle_flinger_deinit(void);
+int vehicle_flinger_reverse_open(struct vehicle_cfg *cfg);
+int vehicle_flinger_reverse_close(void);
+unsigned long vehicle_flinger_request_cif_buffer(int frame_ready);
+void vehicle_flinger_commit_cif_buffer(u32 buf_phy_addr);
+
+enum {
+	RGA_TRANSFORM_ROT_MASK   =   0x0000000F,
+	RGA_TRANSFORM_ROT_0      =   0x00000000,
+	RGA_TRANSFORM_ROT_90     =   0x00000001,
+	RGA_TRANSFORM_ROT_180    =   0x00000002,
+	RGA_TRANSFORM_ROT_270    =   0x00000004,
+
+	RGA_TRANSFORM_FLIP_MASK  =   0x000000F0,
+	RGA_TRANSFORM_FLIP_H     =   0x00000020,
+	RGA_TRANSFORM_FLIP_V     =   0x00000010,
+};
+#endif
diff --git a/drivers/video/rockchip/vehicle/vehicle_generic_sensor.c b/drivers/video/rockchip/vehicle/vehicle_generic_sensor.c
new file mode 100755
index 0000000..fa3109e
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_generic_sensor.c
@@ -0,0 +1,263 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include "vehicle_ad.h"
+#include "vehicle_ad_7181.h"
+#include "vehicle_ad_tp2825.h"
+
+struct ad_dev *g_addev = NULL;
+
+struct vehicle_sensor_ops {
+	const char *name;
+
+	int (*sensor_init)(struct ad_dev *ad);
+	int (*sensor_deinit)(void);
+	int (*sensor_get_cfg)(struct vehicle_cfg **cfg);
+	void (*sensor_check_cif_error)(struct ad_dev *ad, int last_line);
+	int (*sensor_check_id_cb)(struct ad_dev *ad);
+};
+struct vehicle_sensor_ops *sensor_cb;
+
+static struct vehicle_sensor_ops sensor_cb_series[] = {
+	{
+		.name = "adv7181",
+		.sensor_init = adv7181_ad_init,
+		.sensor_deinit = adv7181_ad_deinit,
+		.sensor_get_cfg = adv7181_ad_get_cfg,
+		.sensor_check_cif_error = adv7181_ad_check_cif_error,
+		.sensor_check_id_cb = adv7181_check_id
+	},
+	{
+		.name = "tp2825",
+		.sensor_init = tp2825_ad_init,
+		.sensor_deinit = tp2825_ad_deinit,
+		.sensor_get_cfg = tp2825_ad_get_cfg,
+		.sensor_check_cif_error = tp2825_ad_check_cif_error,
+		.sensor_check_id_cb = tp2825_check_id
+	}
+};
+
+int vehicle_generic_sensor_write(struct ad_dev *ad, char reg, char *pval)
+{
+	struct i2c_msg msg;
+	int ret;
+
+	char *tx_buf = kmalloc(2, GFP_KERNEL);
+
+	if (!tx_buf)
+		return -ENOMEM;
+
+	memcpy(tx_buf, &reg, 1);
+	memcpy(tx_buf+1, (char *)pval, 1);
+
+	msg.addr = ad->i2c_add;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = (char *)tx_buf;
+	msg.scl_rate = ad->i2c_rate;
+
+	ret = i2c_transfer(ad->adapter, &msg, 1);
+	kfree(tx_buf);
+
+	return (ret == 1) ? 4 : ret;
+}
+
+int vehicle_generic_sensor_read(struct ad_dev *ad, char reg)
+{
+	struct i2c_msg msgs[2];
+	int ret;
+	char reg_buf[2];
+	char pval;
+
+	memcpy(reg_buf, &reg, 1);
+
+	msgs[0].addr =	ad->i2c_add;
+	msgs[0].flags = 0;
+	msgs[0].len = 1;
+	msgs[0].buf = reg_buf;
+	msgs[0].scl_rate = ad->i2c_rate;
+
+	msgs[1].addr = ad->i2c_add;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = 1;
+	msgs[1].buf = &pval;
+	msgs[1].scl_rate = ad->i2c_rate;
+
+	ret = i2c_transfer(ad->adapter, msgs, 2);
+
+	return pval;
+}
+
+int vehicle_parse_sensor(struct ad_dev *ad)
+{
+	struct device *dev = ad->dev;
+	struct device_node *node = NULL;
+	struct device_node *cp = NULL;
+	enum of_gpio_flags flags;
+	const char *status = NULL;
+	int i;
+	int ret = 0;
+
+	if (of_property_read_u32(dev->of_node, "ad,fix-format",
+				 &ad->fix_format))
+		DBG("get fix-format failed!\n");
+
+	if (of_property_read_u32(dev->of_node, "vehicle,rotate-mirror",
+				 &ad->cfg.rotate_mirror))
+		DBG("get rotate-mirror failed!\n");
+
+	node = of_parse_phandle(dev->of_node, "rockchip,cif-sensor", 0);
+	if (!node) {
+		DBG("get cif-sensor dts failed\n");
+		return -1;
+	}
+
+	for_each_child_of_node(node, cp) {
+		of_property_read_string(cp, "status", &status);
+		DBG("status: %s\n", status);
+		if (status && strcmp(status, "okay"))
+			continue;
+		DBG("status: %s\n", status);
+
+		if (of_property_read_u32(cp, "i2c_rata", &ad->i2c_rate))
+			DBG("Get %s i2c_rata failed!\n", cp->name);
+		if (of_property_read_u32(cp, "i2c_chl", &ad->i2c_chl))
+			DBG("Get %s i2c_chl failed!\n", cp->name);
+		if (of_property_read_u32(cp, "ad_chl", &ad->ad_chl))
+			DBG("Get %s ad_chl failed!\n", cp->name);
+
+		if (ad->ad_chl > 4 || ad->ad_chl < 0) {
+			DBG("error, ad_chl %d !\n", ad->ad_chl);
+			ad->ad_chl = 0;
+		}
+		if (of_property_read_u32(cp, "mclk_rate", &ad->mclk_rate))
+			DBG("Get %s mclk_rate failed!\n", cp->name);
+
+		if (of_property_read_u32(cp, "pwr_active", &ad->pwr_active))
+			DBG("Get %s pwdn_active failed!\n", cp->name);
+
+		if (of_property_read_u32(cp, "pwdn_active", &ad->pwdn_active))
+			DBG("Get %s pwdn_active failed!\n", cp->name);
+
+		ad->power = of_get_named_gpio_flags(cp, "rockchip,power",
+						    0, &flags);
+		ad->powerdown = of_get_named_gpio_flags(cp,
+							"rockchip,powerdown",
+							0, &flags);
+
+		if (of_property_read_u32(cp, "i2c_add", &ad->i2c_add))
+			DBG("Get %s i2c_add failed!\n", cp->name);
+
+		ad->i2c_add = (ad->i2c_add >> 1);
+
+		if (of_property_read_u32(cp, "resolution", &ad->resolution))
+			DBG("Get %s resolution failed!\n", cp->name);
+
+		of_property_read_u32_array(
+				cp,
+				"rockchip,camera-module-defrect0",
+				(unsigned int *)&ad->defrects[0],
+				6);
+		of_property_read_u32_array(
+				cp,
+				"rockchip,camera-module-defrect1",
+				(unsigned int *)&ad->defrects[1],
+				6);
+		of_property_read_u32_array(
+				cp,
+				"rockchip,camera-module-defrect2",
+				(unsigned int *)&ad->defrects[2],
+				6);
+		of_property_read_u32_array(
+				cp,
+				"rockchip,camera-module-defrect3",
+				(unsigned int *)&ad->defrects[3],
+				6);
+
+		of_property_read_string(
+				cp,
+				"rockchip,camera-module-interface0",
+				&ad->defrects[0].interface);
+		of_property_read_string(
+				cp,
+				"rockchip,camera-module-interface1",
+				&ad->defrects[1].interface);
+		of_property_read_string(
+				cp,
+				"rockchip,camera-module-interface2",
+				&ad->defrects[2].interface);
+		of_property_read_string(
+				cp,
+				"rockchip,camera-module-interface3",
+				&ad->defrects[3].interface);
+
+		ad->ad_name = cp->name;
+		for (i = 0; i < ARRAY_SIZE(sensor_cb_series); i++) {
+			if (!strcmp(ad->ad_name, sensor_cb_series[i].name))
+				sensor_cb = sensor_cb_series + i;
+		}
+
+		DBG("%s: ad_chl=%d,,ad_addr=%x,fix_for=%d\n", ad->ad_name,
+		    ad->ad_chl, ad->i2c_add, ad->fix_format);
+		DBG("gpio power:%d, active:%d\n", ad->power, ad->pwr_active);
+		DBG("gpio powerdown:%d, active:%d\n",
+		    ad->powerdown, ad->pwdn_active);
+		break;
+	}
+	if (!ad->ad_name)
+		ret = -EINVAL;
+
+	return ret;
+}
+
+int vehicle_ad_init(struct ad_dev *ad)
+{
+	int ret = 0;
+
+	if (sensor_cb->sensor_init) {
+		ret = sensor_cb->sensor_init(ad);
+		if (IS_ERR_VALUE(ret)) {
+			DBG("%s sensor_init failed!\n", ad->ad_name);
+			goto end;
+		}
+	} else {
+		DBG("%s sensor_init is NULL!\n", ad->ad_name);
+		ret = -1;
+		goto end;
+	}
+
+	if (sensor_cb->sensor_check_id_cb) {
+		ret = sensor_cb->sensor_check_id_cb(ad);
+		if (IS_ERR_VALUE(ret))
+			DBG("%s check id failed!\n", ad->ad_name);
+	}
+
+end:
+	return ret;
+}
+
+int vehicle_ad_deinit(void)
+{
+	if (sensor_cb->sensor_deinit)
+		return sensor_cb->sensor_deinit();
+	else
+		return -1;
+}
+
+struct vehicle_cfg *ad_get_vehicle_cfg(void)
+{
+	struct vehicle_cfg *cfg;
+
+	if (sensor_cb->sensor_get_cfg)
+		sensor_cb->sensor_get_cfg(&cfg);
+
+	return cfg;
+}
+
+void ad_check_cif_error(struct ad_dev *ad, int last_line)
+{
+	if (sensor_cb->sensor_get_cfg)
+		sensor_cb->sensor_check_cif_error(ad, last_line);
+}
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_gpio.c b/drivers/video/rockchip/vehicle/vehicle_gpio.c
new file mode 100644
index 0000000..4589e70
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_gpio.c
@@ -0,0 +1,159 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <linux/kthread.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/completion.h>
+#include <linux/wakelock.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+
+#include "vehicle_gpio.h"
+#include "vehicle_main.h"
+
+static void gpio_det_work_func(struct work_struct *work)
+{
+	struct gpio_detect *gpiod = container_of(work, struct gpio_detect,
+			work.work);
+	int val = gpio_get_value(gpiod->gpio);
+
+	if (gpiod->val != val) {
+		gpiod->val = val;
+		vehicle_gpio_stat_change_notify();
+	}
+}
+
+static irqreturn_t gpio_det_interrupt(int irq, void *dev_id)
+{
+	struct gpio_detect *gpiod = dev_id;
+	int val = gpio_get_value(gpiod->gpio);
+	unsigned int irqflags = IRQF_ONESHOT;
+
+	if (val)
+		irqflags |= IRQ_TYPE_EDGE_FALLING;
+	else
+		irqflags |= IRQ_TYPE_EDGE_RISING;
+	irq_set_irq_type(gpiod->irq, irqflags);
+
+	mod_delayed_work(system_wq, &gpiod->work,
+			 msecs_to_jiffies(gpiod->debounce_ms));
+	return IRQ_HANDLED;
+}
+
+static int vehicle_gpio_init_check(struct gpio_detect *gpiod)
+{
+	gpiod->val = gpio_get_value(gpiod->gpio);
+	if (gpiod->atv_val == gpiod->val) {
+		vehicle_gpio_stat_change_notify();
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+bool vehicle_gpio_reverse_check(struct gpio_detect *gpiod)
+{
+	int val = gpiod->val ^ gpiod->atv_val;
+
+	return (val == 0) ? true : false;
+}
+
+static int gpio_parse_dt(struct gpio_detect *gpiod)
+{
+	struct device *dev = gpiod->dev;
+	struct device_node *gpiod_node;
+	struct device_node *node;
+	const char *name;
+	int num;
+	int ret = 0;
+
+	gpiod_node = of_parse_phandle(dev->of_node, "rockchip,gpio-det", 0);
+
+	num = of_get_child_count(gpiod_node);
+	if (num == 0)
+		return -ENODEV;
+
+	of_property_read_u32(gpiod_node, "rockchip,camcap-mirror",
+			     &gpiod->mirror);
+	for_each_child_of_node(gpiod_node, node) {
+		enum of_gpio_flags flags;
+
+		name = of_get_property(node, "label", NULL);
+		if (!strcmp(name, "car-reverse")) {
+			gpiod->gpio = of_get_gpio_flags(node, 0, &flags);
+			if (!gpio_is_valid(gpiod->gpio)) {
+				dev_err(dev, "failed to get gpio\n");
+				ret = -1;
+			}
+			gpiod->atv_val = !(flags & OF_GPIO_ACTIVE_LOW);
+			of_property_read_u32(node, "linux,debounce-ms",
+					     &gpiod->debounce_ms);
+			break;
+		}
+	}
+
+	DBG("%s:gpio %d, act_val %d, mirror %d, debounce_ms %d\n",
+	    __func__, gpiod->gpio, gpiod->atv_val, gpiod->mirror,
+	    gpiod->debounce_ms);
+	return ret;
+}
+
+int vehicle_gpio_init(struct gpio_detect *gpiod)
+{
+	int gpio;
+	int ret;
+	unsigned long irqflags = IRQF_ONESHOT;
+
+	if (gpio_parse_dt(gpiod) < 0) {
+		dev_err(gpiod->dev, "%s,parse dt failed\n", __func__);
+		return -1;
+	}
+
+	gpio = gpiod->gpio;
+
+	ret = gpio_request(gpio, "vehicle");
+	if (ret < 0) {
+		dev_err(gpiod->dev, "failed to request gpio %d\n", ret);
+		return -1;
+	}
+
+	gpio_direction_input(gpio);
+
+	gpiod->irq = gpio_to_irq(gpio);
+	if (gpiod->irq < 0) {
+		dev_err(gpiod->dev, "failed to get irq, GPIO %d\n", gpio);
+		return -1;
+	}
+
+	gpiod->val = gpio_get_value(gpio);
+	if (gpiod->val)
+		irqflags |= IRQ_TYPE_EDGE_FALLING;
+	else
+		irqflags |= IRQ_TYPE_EDGE_RISING;
+	ret = devm_request_threaded_irq(gpiod->dev, gpiod->irq,
+					NULL, gpio_det_interrupt,
+					irqflags, "vehicle gpio", gpiod);
+	if (ret < 0)
+		dev_err(gpiod->dev, "request irq(%s) failed:%d\n",
+			"vehicle", ret);
+
+	INIT_DELAYED_WORK(&gpiod->work, gpio_det_work_func);
+
+	vehicle_gpio_init_check(gpiod);
+
+	return 0;
+}
+
+int vehicle_gpio_deinit(struct gpio_detect *gpiod)
+{
+	free_irq(gpiod->irq, gpiod);
+	gpio_free(gpiod->gpio);
+	return 0;
+}
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_gpio.h b/drivers/video/rockchip/vehicle/vehicle_gpio.h
new file mode 100644
index 0000000..9532040
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_gpio.h
@@ -0,0 +1,26 @@
+#ifndef __VEHICLE_GPIO_H
+#define __VEHICLE_GPIO_H
+
+#include "vehicle_cfg.h"
+
+struct gpio_detect {
+	int gpio;
+	int atv_val;
+	int val;
+	int irq;
+	int mirror;
+	unsigned int debounce_ms;
+	struct delayed_work work;
+	struct device *dev;
+};
+/*
+true : reverse on
+false : reverse over
+*/
+bool vehicle_gpio_reverse_check(struct gpio_detect *gpiod);
+
+int vehicle_gpio_init(struct gpio_detect *gpiod);
+
+int vehicle_gpio_deinit(struct gpio_detect *gpiod);
+
+#endif
diff --git a/drivers/video/rockchip/vehicle/vehicle_main.c b/drivers/video/rockchip/vehicle/vehicle_main.c
new file mode 100755
index 0000000..f835d12
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_main.c
@@ -0,0 +1,301 @@
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/fb.h>
+#include <linux/rk_fb.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/completion.h>
+#include <linux/wakelock.h>
+#include <linux/of_gpio.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+#include "vehicle_flinger.h"
+#include "vehicle_cfg.h"
+#include "vehicle_ad.h"
+#include "vehicle_main.h"
+#include "vehicle_cif.h"
+#include "vehicle_gpio.h"
+
+enum {
+	STATE_CLOSE = 0,
+	STATE_OPEN,
+};
+struct vehicle {
+	struct device	*dev;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct wake_lock wake_lock;
+	struct gpio_detect gpio_data;
+	struct vehicle_cif cif;
+	struct ad_dev ad;
+	int mirror;
+	wait_queue_head_t vehicle_wait;
+	atomic_t vehicle_atomic;
+	int state;
+	bool vehicle_need_exit;
+};
+
+struct vehicle *g_vehicle = NULL;
+
+static int vehicle_parse_dt(struct vehicle *vehicle_info)
+{
+	struct device	*dev = vehicle_info->dev;
+
+	DBG("%s\n", __func__);
+
+	/*  1. pinctrl */
+	vehicle_info->pinctrl = pinctrl_get(dev);
+	if (IS_ERR(vehicle_info->pinctrl)) {
+		dev_err(dev, "pinctrl get failed\n");
+		return PTR_ERR(vehicle_info->pinctrl);
+	}
+	vehicle_info->pins_default = pinctrl_lookup_state(vehicle_info->pinctrl,
+			"vehicle");
+	if (IS_ERR(vehicle_info->pins_default))
+		dev_err(dev, "get default pinstate failed\n");
+	else
+		pinctrl_select_state(vehicle_info->pinctrl,
+				     vehicle_info->pins_default);
+	return 0;
+}
+
+void vehicle_ad_stat_change_notify(void)
+{
+	if (g_vehicle)
+		atomic_set(&g_vehicle->vehicle_atomic, 1);
+}
+
+void vehicle_gpio_stat_change_notify(void)
+{
+	if (g_vehicle)
+		atomic_set(&g_vehicle->vehicle_atomic, 1);
+}
+
+void vehicle_cif_error_notify(int last_line)
+{
+	if (g_vehicle)
+		ad_check_cif_error(&g_vehicle->ad, last_line);
+}
+
+static void vehicle_open(struct vehicle_cfg *v_cfg)
+{
+	vehicle_flinger_reverse_open(v_cfg);
+	vehicle_cif_reverse_open(v_cfg);
+}
+static void vehicle_close(void)
+{
+	vehicle_cif_reverse_close();
+	vehicle_flinger_reverse_close();
+}
+static int vehicle_state_change(struct vehicle *v)
+{
+	struct vehicle_cfg *v_cfg;
+	struct gpio_detect *gpiod = &v->gpio_data;
+	bool gpio_reverse_on;
+
+	gpio_reverse_on = vehicle_gpio_reverse_check(gpiod);
+	v_cfg = ad_get_vehicle_cfg();
+
+	if (!v_cfg)
+		return -1;
+
+	DBG("%s, gpio = reverse %s, ad width = %d, state=%d, ad ready %d\n", __func__,
+	    gpio_reverse_on ? "on" : "over", v_cfg->width, v->state, v_cfg->ad_ready);
+	switch (v->state) {
+	case STATE_CLOSE:
+		/*  reverse on & video in */
+		if (gpio_reverse_on && v_cfg->ad_ready) {
+			vehicle_open(v_cfg);
+			v->state = STATE_OPEN;
+		}
+		break;
+	case STATE_OPEN:
+		/*  reverse exit || video loss */
+		if (!gpio_reverse_on || !v_cfg->ad_ready) {
+			vehicle_close();
+			v->state = STATE_CLOSE;
+		}
+		/*  reverse on & video format change */
+		if (gpio_reverse_on && v_cfg->ad_ready) {
+			vehicle_open(v_cfg);
+		}
+		break;
+	}
+	return 0;
+}
+
+static int vehicle_probe(struct platform_device *pdev)
+{
+	struct vehicle *vehicle_info;
+
+	vehicle_info = devm_kzalloc(&pdev->dev,
+				    sizeof(struct vehicle), GFP_KERNEL);
+	if (!vehicle_info)
+		return -ENOMEM;
+
+	vehicle_info->dev = &pdev->dev;
+	vehicle_info->gpio_data.dev = &pdev->dev;
+	vehicle_info->cif.dev = &pdev->dev;
+	vehicle_info->ad.dev = &pdev->dev;
+
+	dev_set_name(vehicle_info->dev, "vehicle_main");
+	if (!pdev->dev.of_node)
+		return -EINVAL;
+
+	vehicle_parse_dt(vehicle_info);
+
+	if (IS_ERR_VALUE(vehicle_parse_sensor(&vehicle_info->ad))) {
+		DBG("parse sensor failed!\n");
+		pinctrl_put(vehicle_info->pinctrl);
+		return -EINVAL;
+	}
+
+	wake_lock_init(&vehicle_info->wake_lock, WAKE_LOCK_SUSPEND, "vehicle");
+
+	dev_info(vehicle_info->dev, "vehicle driver probe success\n");
+
+	init_waitqueue_head(&vehicle_info->vehicle_wait);
+	atomic_set(&vehicle_info->vehicle_atomic, 0);
+	vehicle_info->state = STATE_CLOSE;
+	vehicle_info->vehicle_need_exit = false;
+
+	g_vehicle = vehicle_info;
+	return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id vehicle_of_match[] = {
+	{ .compatible = "vehicle", },
+	{},
+};
+#endif
+
+static struct platform_driver vehicle_driver = {
+	.driver     = {
+		.name   = "vehicle",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(vehicle_of_match),
+	},
+	.probe      = vehicle_probe,
+};
+
+void vehicle_exit_notify(void)
+{
+	if (g_vehicle)
+		g_vehicle->vehicle_need_exit = true;
+}
+static void vehicle_exit_complete_notify(struct vehicle *v)
+{
+	char *status = NULL;
+	char *envp[2];
+
+	if (!v)
+		return;
+	status = kasprintf(GFP_KERNEL, "vehicle_exit=done");
+	envp[0] = status;
+	envp[1] = NULL;
+	wake_lock_timeout(&v->wake_lock, 5 * HZ);
+	kobject_uevent_env(&v->dev->kobj, KOBJ_CHANGE, envp);
+
+	DBG("%s: uevent:Vehicle exit done\r\n", __func__);
+	kfree(status);
+}
+
+extern int rk_camera_init(void);
+extern int gpio_det_init(void);
+
+int rk_vehicle_system_main(void *arg)
+{
+	int ret = -1;
+	struct vehicle *v = g_vehicle;
+
+	if (!g_vehicle) {
+		DBG("vehicle probe failed, g_vehicle is NULL.\n");
+		goto VEHICLE_EXIT;
+	}
+
+	/*  1.ad */
+	ret = vehicle_ad_init(&v->ad);
+	if (IS_ERR_VALUE(ret)) {
+		DBG("rk_vehicle_system_main: ad init failed\r\n");
+		goto VEHICLE_AD_DEINIT;
+	}
+
+	/*  2. flinger */
+	ret = vehicle_flinger_init(v->dev);
+	if (IS_ERR_VALUE(ret)) {
+		DBG("rk_vehicle_system_main: flinger init failed\r\n");
+		goto VEHICLE_FLINGER_DEINIT;
+	}
+
+	/*  3. cif init */
+	ret = vehicle_cif_init(&v->cif);
+	if (IS_ERR_VALUE(ret)) {
+		DBG("rk_vehicle_system_main: cif init failed\r\n");
+		goto VEHICLE_CIF_DEINIT;
+	}
+
+	/*  4. gpio init and check state */
+	vehicle_gpio_init(&v->gpio_data);
+	if (IS_ERR_VALUE(ret)) {
+		DBG("rk_vehicle_system_main: gpio init failed\r\n");
+		goto VEHICLE_GPIO_DEINIT;
+	}
+
+	DBG("yuyz %s init success, start loop\n", __func__);
+
+	while (STATE_OPEN == v->state || !v->vehicle_need_exit) {
+		wait_event_timeout(v->vehicle_wait,
+				   atomic_read(&v->vehicle_atomic),
+				   msecs_to_jiffies(100));
+		if (atomic_read(&v->vehicle_atomic)) {
+			vehicle_state_change(v);
+			atomic_set(&v->vehicle_atomic, 0);
+		}
+	}
+
+VEHICLE_GPIO_DEINIT:
+	vehicle_gpio_deinit(&v->gpio_data);
+	if (v->pinctrl)
+		pinctrl_put(v->pinctrl);
+
+VEHICLE_CIF_DEINIT:
+	vehicle_cif_deinit(&v->cif);
+
+VEHICLE_FLINGER_DEINIT:
+	vehicle_flinger_reverse_close();
+	vehicle_flinger_deinit();
+
+VEHICLE_AD_DEINIT:
+	vehicle_ad_deinit();
+
+	/*Init normal drivers*/
+VEHICLE_EXIT:
+	rk_camera_init();
+	//gpio_det_init();
+
+	msleep(100);
+	vehicle_exit_complete_notify(v);
+	return 0;
+}
+
+static int __init vehicle_system_start(void)
+{
+	DBG("vehicle_system_start:start vehicle system \r\n");
+	platform_driver_register(&vehicle_driver);
+	kthread_run(rk_vehicle_system_main, NULL, "vehicle main");
+	return 0;
+}
+
+/* rootfs_initcall(vehicle_system_start); */
+/* rootfs_initcall(vehicle_system_start); */
+subsys_initcall_sync(vehicle_system_start);
+/* fs_initcall_sync(vehicle_system_start); */
+
diff --git a/drivers/video/rockchip/vehicle/vehicle_main.h b/drivers/video/rockchip/vehicle/vehicle_main.h
new file mode 100644
index 0000000..9928ba0
--- /dev/null
+++ b/drivers/video/rockchip/vehicle/vehicle_main.h
@@ -0,0 +1,10 @@
+#ifndef __VEHICLE_MAIN_H
+#define __VEHICLE_MAIN_H
+
+/* impl by vehicle_main, call by ad detect */
+void vehicle_ad_stat_change_notify(void);
+void vehicle_gpio_stat_change_notify(void);
+void vehicle_cif_error_notify(int last_line);
+void vehicle_exit_notify(void);
+
+#endif
diff --git a/include/linux/rk_fb.h b/include/linux/rk_fb.h
index 7a00ac8..9f80d69 100755
--- a/include/linux/rk_fb.h
+++ b/include/linux/rk_fb.h
@@ -72,6 +72,7 @@
 #define RK_FBIOGET_LIST_STA  				0X4631
 #define RK_FBIOGET_IOMMU_STA				0x4632
 #define RK_FBIOSET_CLEAR_FB				0x4633
+#define RK_FBIOSET_CAR_CONFIG_DONE			0x4634
 
 
 /**rk fb events**/
@@ -603,6 +604,26 @@ struct rk_lcdc_drv_ops {
 				  int *st2084oetf_yn_for_hdr);
 };
 
+struct rk_fb_direct_show {
+   u32 rgb_mst;
+   int format;
+   u16 xact;
+   u16 yact;
+   u16 xvir;
+   int ymirror;
+};
+
+struct rk_fb_car_par {
+   bool fb_inited;
+   int car_reversing;
+   int logo_showing;
+   struct rk_fb_direct_show direct_show;
+   int screen_width;
+   int screen_height;
+   struct device *dev;
+   int iommu_enabled;
+};
+
 struct rk_fb_area_par {
 	u8  data_format;        /*layer data fmt*/
 	short ion_fd;
@@ -876,5 +897,9 @@ int rk_fb_pixel_width(int data_format);
 void trace_buffer_dump(struct device *dev,
 			      struct rk_lcdc_driver *dev_drv);
 int rk_fb_set_car_reverse_status(struct rk_lcdc_driver *dev_drv, int status);
+int rk_set_dsp(int cmd, unsigned long arg);
+int rk_set_car_reverse(bool reversing);
+struct rk_fb_car_par *rk_fb_get_car_par(void);
+
 extern int rockchip_get_screen_type(void);
 #endif
-- 
1.9.1

